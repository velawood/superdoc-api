---
phase: 04-read-endpoint
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/routes/read.mjs
  - src/app.mjs
autonomous: true

must_haves:
  truths:
    - "POST /v1/read with a valid DOCX file returns 200 with JSON containing blocks, outline, definedTerms, and idMapping"
    - "POST /v1/read without a file returns 400 with MISSING_FILE error code"
    - "POST /v1/read with a non-DOCX file (wrong magic bytes) returns 400 with INVALID_FILE_TYPE error code"
    - "POST /v1/read with a corrupted DOCX returns 422 with EXTRACTION_FAILED error code"
    - "POST /v1/read without auth returns 401 (inherits from Phase 2 auth scope)"
  artifacts:
    - path: "src/routes/read.mjs"
      provides: "POST /v1/read route handler"
      exports: ["default"]
      contains: "extractDocumentIRFromBuffer"
    - path: "src/app.mjs"
      provides: "App factory with read route registered in /v1 scope"
      contains: "readRoutes"
  key_links:
    - from: "src/routes/read.mjs"
      to: "src/irExtractor.mjs"
      via: "import extractDocumentIRFromBuffer"
      pattern: "extractDocumentIRFromBuffer"
    - from: "src/routes/read.mjs"
      to: "src/validation/file-upload.mjs"
      via: "import validateMagicBytes and checkZipBomb"
      pattern: "validateMagicBytes|checkZipBomb"
    - from: "src/app.mjs"
      to: "src/routes/read.mjs"
      via: "import and register in /v1 scope"
      pattern: "readRoutes"
---

<objective>
Create the POST /v1/read endpoint that accepts a DOCX file upload via multipart/form-data, runs the Phase 3 validation pipeline (magic bytes + zip bomb), calls extractDocumentIRFromBuffer() to extract the document IR, and returns the full IR as JSON.

Purpose: This is the first domain-integrated endpoint -- it connects the HTTP layer (Phases 1-3) with the existing document processing domain module (irExtractor). Users can now programmatically extract structured document data via HTTP.

Output: Working POST /v1/read endpoint registered in the /v1 protected scope, returning complete IR (blocks, outline, definedTerms, idMapping) as JSON.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-read-endpoint/04-RESEARCH.md
@.planning/phases/02-auth-and-error-handling/02-01-SUMMARY.md
@src/app.mjs
@src/irExtractor.mjs
@src/editorFactory.mjs
@src/hooks/content-type-check.mjs
@src/plugins/auth.mjs
@src/routes/health.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create read route handler and register in app</name>
  <files>src/routes/read.mjs, src/app.mjs</files>
  <action>
Create `src/routes/read.mjs` as an async Fastify route plugin (same pattern as `src/routes/health.mjs`):

1. **Route definition:** `fastify.post("/read", { preHandler: [requireMultipart] }, handler)` -- attach the requireMultipart preHandler from `src/hooks/content-type-check.mjs` to enforce multipart Content-Type before the handler runs.

2. **Handler flow (6 steps):**
   - Step 1: `const data = await request.file()` -- get uploaded file from @fastify/multipart. If `!data`, return 400 with `{ error: { code: "MISSING_FILE", message: "No file uploaded", details: [] } }`.
   - Step 2: `const buffer = await data.toBuffer()` -- buffer the file. Extract `data.filename || "document.docx"` for metadata.
   - Step 3: Call `validateMagicBytes(buffer)` from `src/validation/file-upload.mjs`. If `!result.valid`, return 400 with `{ error: { code: "INVALID_FILE_TYPE", message: result.error, details: [] } }`.
   - Step 4: Call `await checkZipBomb(buffer)` from `src/validation/file-upload.mjs`. If `!result.safe`, return 400 with `{ error: { code: "ZIP_BOMB_DETECTED", message: result.error, details: [] } }`.
   - Step 5: Call `await extractDocumentIRFromBuffer(buffer, filename, { format: "full", includeDefinedTerms: true, includeOutline: true })` from `src/irExtractor.mjs`, wrapped in try/catch. On success, proceed to step 6. On error, log with `request.log.error({ err: error, filename }, "Document extraction failed")` and return 422 with `{ error: { code: "EXTRACTION_FAILED", message: "Unable to process document", details: [] } }`.
   - Step 6: `return reply.type("application/json").send(ir)` -- return the IR object. Fastify serializes to JSON automatically.

3. **Imports needed in read.mjs:**
   - `import { extractDocumentIRFromBuffer } from "../irExtractor.mjs"`
   - `import { validateMagicBytes, checkZipBomb } from "../validation/file-upload.mjs"`
   - `import { requireMultipart } from "../hooks/content-type-check.mjs"`

4. **Export:** `export default readRoutes` (the async plugin function).

5. **JSDoc:** Add comprehensive JSDoc matching the project conventions (see CONVENTIONS.md). Document the route, parameters, response structure, error codes.

Then update `src/app.mjs`:

1. Add import: `import readRoutes from "./routes/read.mjs"`
2. Inside the `protectedRoutes` async function (the /v1 scope), add: `scope.register(readRoutes)` after `scope.register(healthRoutes)`.
3. Replace the `// Future: upload routes, read routes, etc.` comment with the actual registration.

**Important notes:**
- Do NOT wrap with fastify-plugin. The read route should be scoped to /v1 (same pattern as health routes within the protected scope).
- Use 422 (Unprocessable Entity) for domain extraction failures, NOT 500. The file passed validation but the DOCX content is corrupted/unsupported.
- Do NOT call `JSON.stringify()` manually -- use `reply.send(ir)` and let Fastify handle serialization.
- Do NOT create temp files -- use the buffer API (`extractDocumentIRFromBuffer`), not the file path API (`extractDocumentIR`).
- The `requireMultipart` hook must be imported as a named export (check `src/hooks/content-type-check.mjs` for exact export syntax).
  </action>
  <verify>
1. Run `node -e "import('./src/routes/read.mjs').then(m => console.log('read.mjs loads OK, exports:', Object.keys(m)))"` -- should load without import errors and show default export.
2. Run `node -e "import('./src/app.mjs').then(m => { const app = m.default({ logger: false, apiKey: 'test' }); app.ready().then(() => { console.log('App boots OK'); app.close(); }).catch(e => console.error('Boot failed:', e.message)) })"` -- app should boot without errors (assuming Phase 3 deps are available).
3. Verify the file structure: `src/routes/read.mjs` exists, `src/app.mjs` imports and registers readRoutes.
  </verify>
  <done>
- `src/routes/read.mjs` exists with POST /read handler that chains validation + extraction + JSON response
- `src/app.mjs` registers readRoutes inside the /v1 protected scope
- Route handler uses extractDocumentIRFromBuffer (not file path API)
- Route handler uses requireMultipart preHandler
- Route handler returns proper error codes: 400 (MISSING_FILE, INVALID_FILE_TYPE, ZIP_BOMB_DETECTED), 422 (EXTRACTION_FAILED)
- Domain errors are logged server-side and sanitized for the client
  </done>
</task>

</tasks>

<verification>
1. `src/routes/read.mjs` exports a default async Fastify plugin function
2. The route is POST /read (mounted under /v1 prefix = POST /v1/read)
3. The handler chains: file extraction -> magic bytes -> zip bomb -> IR extraction -> JSON response
4. Error responses use the established `{ error: { code, message, details } }` format
5. `src/app.mjs` imports and registers readRoutes in the /v1 scope
6. No new dependencies required (all imports from existing modules)
</verification>

<success_criteria>
- POST /v1/read endpoint is defined and registered
- Handler follows the 6-step flow: file -> buffer -> magic bytes -> zip bomb -> extract IR -> return JSON
- Error handling covers: missing file (400), invalid type (400), zip bomb (400), extraction failure (422)
- The route inherits Bearer auth from the /v1 scope (no additional auth code needed)
- Content-Type validation via requireMultipart preHandler
</success_criteria>

<output>
After completion, create `.planning/phases/04-read-endpoint/04-01-SUMMARY.md`
</output>
