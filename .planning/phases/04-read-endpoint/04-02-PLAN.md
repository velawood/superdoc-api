---
phase: 04-read-endpoint
plan: 02
type: tdd
wave: 2
depends_on: ["04-01"]
files_modified:
  - tests_and_others/tests/read.test.mjs
autonomous: true

must_haves:
  truths:
    - "Valid DOCX upload returns 200 with complete IR (metadata, blocks, outline, idMapping)"
    - "Missing file upload returns 400 with MISSING_FILE error code"
    - "Non-DOCX file (wrong magic bytes) returns 400 with INVALID_FILE_TYPE error code"
    - "Corrupted DOCX (valid ZIP header but bad content) returns 422 with EXTRACTION_FAILED error code"
    - "Unauthenticated request returns 401"
    - "Non-multipart Content-Type returns 400 with INVALID_CONTENT_TYPE error code"
    - "Response includes all IR sections in a single JSON payload (no pagination)"
  artifacts:
    - path: "tests_and_others/tests/read.test.mjs"
      provides: "Integration tests for POST /v1/read endpoint"
      min_lines: 100
  key_links:
    - from: "tests_and_others/tests/read.test.mjs"
      to: "src/app.mjs"
      via: "import buildApp and use fastify.inject()"
      pattern: "buildApp|app\\.inject"
    - from: "tests_and_others/tests/read.test.mjs"
      to: "tests_and_others/tests/fixtures/sample.docx"
      via: "readFile for test DOCX fixture"
      pattern: "readFile.*sample\\.docx|fixtures"
---

<objective>
TDD the POST /v1/read endpoint behavior: write tests first that define the expected contract (valid DOCX returns IR, invalid inputs return proper errors), then verify they pass against the implementation from Plan 01.

Purpose: Validate that the read endpoint correctly integrates file upload handling, validation pipeline, and domain module extraction. Tests define the contract that future changes must not break.

Output: Comprehensive test suite for POST /v1/read covering happy path, error cases, and auth enforcement.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-read-endpoint/04-RESEARCH.md
@.planning/phases/04-read-endpoint/04-01-SUMMARY.md
@src/routes/read.mjs
@src/app.mjs
@tests_and_others/tests/server.test.mjs
</context>

<feature>
  <name>POST /v1/read endpoint contract tests</name>
  <files>tests_and_others/tests/read.test.mjs</files>
  <behavior>
    Test the complete HTTP contract for POST /v1/read:

    **Happy path:**
    - POST /v1/read with valid DOCX + valid auth -> 200
    - Response body has metadata (filename, generated, version, blockCount, format, idsAssigned)
    - Response body has blocks (array, length > 0)
    - Response body has idMapping (object with UUID -> seqId entries)
    - Response body has outline (array)
    - metadata.filename matches uploaded filename
    - metadata.format is "full"
    - Content-Type is application/json

    **Error cases:**
    - No file in multipart body -> 400, error.code = "MISSING_FILE"
    - Non-DOCX file (PNG magic bytes) -> 400, error.code = "INVALID_FILE_TYPE"
    - Corrupted DOCX (ZIP header + garbage) -> 422, error.code = "EXTRACTION_FAILED"
    - 422 error message is generic ("Unable to process document"), no internal details

    **Auth enforcement:**
    - No Authorization header -> 401
    - Invalid Bearer token -> 401

    **Content-Type enforcement:**
    - Non-multipart Content-Type (application/json) -> 400, error.code = "INVALID_CONTENT_TYPE"

    **Response structure:**
    - All error responses have { error: { code, message, details } } structure
    - details is always an array
    - All responses include X-Request-Id header
  </behavior>
  <implementation>
    Create `tests_and_others/tests/read.test.mjs` following the established test patterns from `server.test.mjs`:

    1. **Test setup pattern:** Use `buildApp({ logger: false, apiKey: "test-key-read" })` with separate app instances per describe suite for isolation. Call `await app.ready()` in before() and `await app.close()` in after().

    2. **Multipart payload helper:** Create a `buildMultipartPayload(filename, buffer)` helper function that constructs a valid multipart/form-data payload with boundary, Content-Disposition header, and content. Return `{ payload, contentType }` for use with `app.inject()`.

    3. **Test fixture:** Use `tests_and_others/tests/fixtures/sample.docx` (already exists) as the valid DOCX fixture. Load it with `readFile()` in a before() hook.

    4. **Synthetic test data:**
    - PNG magic bytes: `Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a])`
    - Corrupted DOCX: `Buffer.concat([Buffer.from([0x50, 0x4b, 0x03, 0x04]), Buffer.alloc(100, 0xff)])` (valid ZIP header + garbage)

    5. **Assertion patterns:** Use `assert.equal()` for status codes and string values, `assert.ok()` for truthiness, `assert.deepEqual()` for object shape. Check error response structure with `body.error.code`, `body.error.message`, `Array.isArray(body.error.details)`.

    6. **Suites:**
    - "POST /v1/read - Happy Path" (4-5 tests)
    - "POST /v1/read - Validation Errors" (3-4 tests)
    - "POST /v1/read - Auth and Headers" (3 tests)
  </implementation>
</feature>

<verification>
Run the full test suite:
```bash
node --test tests_and_others/tests/read.test.mjs
```

All tests should pass. If any fail, fix the test or the implementation as needed (since this is TDD plan 02 running after plan 01 implementation, tests should largely pass -- any failures indicate gaps in the plan 01 implementation that need fixing).

Also verify no regressions in existing tests:
```bash
npm test
```
</verification>

<success_criteria>
- `tests_and_others/tests/read.test.mjs` exists with at least 10 test cases
- Tests cover: valid DOCX (200 + IR structure), missing file (400), non-DOCX (400), corrupted DOCX (422), no auth (401), wrong Content-Type (400)
- All tests pass with `node --test tests_and_others/tests/read.test.mjs`
- Existing tests continue to pass with `npm test`
- Tests use established patterns: node:test, assert/strict, buildApp, app.inject()
</success_criteria>

<output>
After completion, create `.planning/phases/04-read-endpoint/04-02-SUMMARY.md`
</output>
