---
phase: 05-resource-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/editorFactory.mjs
  - src/irExtractor.mjs
  - src/plugins/concurrency-limiter.mjs
  - src/plugins/resource-cleanup.mjs
  - src/routes/read.mjs
  - src/app.mjs
  - package.json
autonomous: true

must_haves:
  truths:
    - "After processing a document, the JSDOM window is closed and editor is destroyed (no retained references)"
    - "When multiple requests arrive simultaneously, excess requests queue instead of spawning unbounded JSDOM instances"
    - "A request that fails mid-processing releases the semaphore and cleans up JSDOM (no deadlock after errors)"
  artifacts:
    - path: "src/editorFactory.mjs"
      provides: "Editor factory returning {editor, cleanup} tuple with async window.close()"
      contains: "setImmediate"
    - path: "src/plugins/concurrency-limiter.mjs"
      provides: "Fastify plugin decorating instance with documentSemaphore"
      exports: ["default"]
    - path: "src/plugins/resource-cleanup.mjs"
      provides: "onResponse hook for post-response JSDOM cleanup and semaphore release"
      exports: ["default"]
    - path: "src/routes/read.mjs"
      provides: "Read route with semaphore acquire/release and cleanup on error paths"
      contains: "documentSemaphore"
    - path: "src/app.mjs"
      provides: "App factory registering concurrency-limiter and resource-cleanup plugins"
      contains: "concurrency-limiter"
  key_links:
    - from: "src/editorFactory.mjs"
      to: "src/irExtractor.mjs"
      via: "createHeadlessEditor returns {editor, cleanup}"
      pattern: "const \\{ editor, cleanup \\}"
    - from: "src/plugins/concurrency-limiter.mjs"
      to: "src/routes/read.mjs"
      via: "fastify.documentSemaphore decorator"
      pattern: "fastify\\.documentSemaphore"
    - from: "src/plugins/resource-cleanup.mjs"
      to: "src/routes/read.mjs"
      via: "request.editorCleanup stored by route, invoked by hook"
      pattern: "request\\.editorCleanup"
---

<objective>
Implement JSDOM lifecycle cleanup, concurrency limiting, and resource cleanup hooks across the server.

Purpose: Prevent memory leaks from unclosed JSDOM windows, OOM crashes from unbounded concurrent document processing, and ensure cleanup runs on both success and error paths. This is critical infrastructure before the memory-intensive Apply endpoint (Phase 6).

Output: Modified editor factory with cleanup function, concurrency limiter plugin, resource cleanup hook plugin, updated read route with semaphore integration, and updated app registration.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resource-management/05-RESEARCH.md

@src/editorFactory.mjs
@src/irExtractor.mjs
@src/routes/read.mjs
@src/app.mjs
@src/plugins/multipart.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install async-sema and modify editor factory to return cleanup function</name>
  <files>package.json, src/editorFactory.mjs, src/irExtractor.mjs</files>
  <action>
1. Install async-sema: `npm install async-sema`

2. Modify `src/editorFactory.mjs` - `createHeadlessEditor()`:
   - Instead of returning just the editor, return `{ editor, cleanup }` tuple
   - The cleanup function must:
     a. Call `editor.destroy()` to release SuperDoc resources
     b. Defer `window.close()` via `setImmediate()` to prevent memory retention (per JSDOM issue #1682)
     c. Wrap window.close() in try-catch (window may already be closed)
   - Capture the `window` reference in the closure BEFORE returning
   - Update JSDoc to document the new return type and cleanup contract
   - Update `createEditorFromFile()` to pass through the new return shape
   - Update `createSuggestingEditor()` to pass through the new return shape

3. Update `src/irExtractor.mjs` to use the new return shape:
   - In `extractDocumentIR()`: destructure `{ editor, cleanup }`, call `cleanup()` instead of `editor.destroy()` in the cleanup step (step 7)
   - In `extractDocumentIRFromBuffer()`: destructure `{ editor, cleanup }`, call `cleanup()` instead of `editor.destroy()`
   - In `createEditorWithIR()`: destructure `{ editor, cleanup }`, return the cleanup function instead of `() => editor.destroy()`

IMPORTANT: The cleanup function pattern is `() => { editor.destroy(); setImmediate(() => { try { window.close(); } catch (e) {} }); }` - the setImmediate is critical for preventing JSDOM memory leaks.
  </action>
  <verify>
Run `node -e "import('./src/editorFactory.mjs').then(m => console.log(typeof m.createHeadlessEditor))"` to verify the module loads.
Run `node -e "import('./src/irExtractor.mjs').then(m => console.log(typeof m.extractDocumentIR))"` to verify irExtractor loads with the updated import.
  </verify>
  <done>
createHeadlessEditor returns {editor, cleanup} tuple. cleanup() calls editor.destroy() then defers window.close() via setImmediate. All irExtractor functions use the new cleanup function instead of direct editor.destroy().
  </done>
</task>

<task type="auto">
  <name>Task 2: Create concurrency limiter and resource cleanup plugins, update read route and app</name>
  <files>src/plugins/concurrency-limiter.mjs, src/plugins/resource-cleanup.mjs, src/routes/read.mjs, src/app.mjs</files>
  <action>
1. Create `src/plugins/concurrency-limiter.mjs`:
   - Import `Sema` from `async-sema` and `fp` from `fastify-plugin`
   - Create async plugin function that:
     a. Reads `maxConcurrency` from opts (default: `parseInt(process.env.MAX_DOCUMENT_CONCURRENCY) || 4`)
     b. Creates `new Sema(maxConcurrency)`
     c. Decorates fastify with `fastify.decorate('documentSemaphore', semaphore)`
     d. Logs initialization with maxConcurrency value
   - Export wrapped with `fp()`, name: `'concurrency-limiter'`

2. Create `src/plugins/resource-cleanup.mjs`:
   - Import `fp` from `fastify-plugin`
   - Create async plugin function that adds `onResponse` hook:
     a. Check if `request.editorCleanup` exists (set by route handlers)
     b. If yes: call `request.editorCleanup()` in try-catch, log debug message
     c. Then release semaphore: `fastify.documentSemaphore.release()` in separate try-catch
     d. CRITICAL: cleanup and release are in separate try-catch blocks so release always runs even if cleanup throws
   - Export wrapped with `fp()`, name: `'resource-cleanup'`, dependencies: `['concurrency-limiter']`

3. Update `src/routes/read.mjs`:
   - Import `createHeadlessEditor` from `../editorFactory.mjs` (currently uses extractDocumentIRFromBuffer which handles editor internally)
   - The current flow calls `extractDocumentIRFromBuffer()` which internally creates and destroys the editor. This needs to change because we need to:
     a. Acquire the semaphore BEFORE creating the editor
     b. Store the cleanup function on the request for the onResponse hook
   - New flow in the route handler:
     a. After validation passes (magic bytes + zip bomb), acquire semaphore: `await fastify.documentSemaphore.acquire()`
     b. Wrap editor creation and IR extraction in try-catch
     c. In try block: call `createHeadlessEditor(buffer)` to get `{ editor, cleanup }`, then call `extractIRFromEditor(editor, filename, options)` to get IR, store `request.editorCleanup = cleanup` for the onResponse hook
     d. In catch block: if cleanup exists, call it immediately. Release semaphore immediately (`fastify.documentSemaphore.release()`). Return 422 error response. Set `request.editorCleanup = null` so onResponse hook doesn't double-cleanup.
     e. On success path: return IR. The onResponse hook handles cleanup and semaphore release.
   - Update imports: add `createHeadlessEditor` from `../editorFactory.mjs`, add `extractIRFromEditor` from `../irExtractor.mjs`
   - Remove import of `extractDocumentIRFromBuffer` (no longer needed in route)

4. Update `src/app.mjs`:
   - Import `concurrencyLimiterPlugin` from `./plugins/concurrency-limiter.mjs`
   - Import `resourceCleanupPlugin` from `./plugins/resource-cleanup.mjs`
   - Register concurrency limiter BEFORE resource cleanup (dependency order)
   - Register both at the top-level (global, not scoped to /v1) using `app.register(concurrencyLimiterPlugin)` and `app.register(resourceCleanupPlugin)`
   - Place registration after multipartPlugin but before route registration

CRITICAL ORDER in app.mjs: requestIdPlugin -> errorHandlerPlugin -> multipartPlugin -> concurrencyLimiterPlugin -> resourceCleanupPlugin -> routes
  </action>
  <verify>
Run `node -e "import('./src/app.mjs').then(m => { const app = m.default({ logger: false, apiKey: 'test' }); app.ready().then(() => { console.log('has semaphore:', !!app.documentSemaphore); app.close(); }); })"` to verify the app boots with the semaphore decorator.
Run `node --test tests_and_others/tests/read.test.mjs` to verify existing read endpoint tests still pass with the new resource management integration.
  </verify>
  <done>
Concurrency limiter plugin decorates fastify with documentSemaphore (configurable via MAX_DOCUMENT_CONCURRENCY env var, default 4). Resource cleanup plugin runs onResponse to invoke editorCleanup and release semaphore. Read route acquires semaphore before editor creation and handles cleanup on both success and error paths. All existing read tests pass.
  </done>
</task>

</tasks>

<verification>
1. `node --test tests_and_others/tests/read.test.mjs` - All existing read endpoint tests pass (happy path, validation errors, auth)
2. `node --test tests_and_others/tests/server.test.mjs` - Server bootstrap tests pass
3. `node --test tests_and_others/tests/auth.test.mjs` - Auth tests pass
4. Module imports work: `node -e "import('./src/app.mjs').then(() => console.log('OK'))"`
5. Semaphore accessible: `node -e "import('./src/app.mjs').then(m => { const app = m.default({ logger: false, apiKey: 'test' }); app.ready().then(() => { console.log(app.documentSemaphore); app.close(); }); })"`
</verification>

<success_criteria>
- createHeadlessEditor returns {editor, cleanup} with async window.close() in cleanup
- Concurrency limiter plugin registered globally with configurable max (default 4)
- Resource cleanup hook releases JSDOM and semaphore on every response
- Read route acquires semaphore, handles cleanup on error and success paths
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/05-resource-management/05-01-SUMMARY.md`
</output>
