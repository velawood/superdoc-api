---
phase: 05-resource-management
plan: 02
type: tdd
wave: 2
depends_on: ["05-01"]
files_modified:
  - tests_and_others/tests/resource-management.test.mjs
autonomous: true

must_haves:
  truths:
    - "Tests verify that createHeadlessEditor returns {editor, cleanup} with cleanup callable"
    - "Tests verify that concurrent requests beyond maxConcurrency are queued (not rejected)"
    - "Tests verify that cleanup runs on error paths (semaphore released, no deadlock)"
    - "Tests verify that the onResponse hook invokes editorCleanup and releases semaphore"
  artifacts:
    - path: "tests_and_others/tests/resource-management.test.mjs"
      provides: "Test suite covering editor cleanup, concurrency limiting, and error path cleanup"
      min_lines: 80
  key_links:
    - from: "tests_and_others/tests/resource-management.test.mjs"
      to: "src/editorFactory.mjs"
      via: "import createHeadlessEditor"
      pattern: "createHeadlessEditor"
    - from: "tests_and_others/tests/resource-management.test.mjs"
      to: "src/app.mjs"
      via: "import buildApp for integration tests"
      pattern: "buildApp"
---

<objective>
Create comprehensive tests for the resource management layer: editor cleanup function, concurrency limiter behavior, and error path cleanup.

Purpose: Verify that the Phase 5 resource management implementation correctly prevents memory leaks, limits concurrency, and handles cleanup on all code paths.

Output: Test file covering editor factory cleanup contract, semaphore behavior, and integration tests for resource management through the read endpoint.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resource-management/05-01-SUMMARY.md

@src/editorFactory.mjs
@src/plugins/concurrency-limiter.mjs
@src/plugins/resource-cleanup.mjs
@src/routes/read.mjs
@src/app.mjs
@tests_and_others/tests/read.test.mjs
</context>

<feature>
  <name>Resource Management Tests</name>
  <files>tests_and_others/tests/resource-management.test.mjs</files>
  <behavior>
    Expected behavior in testable terms:

    **Editor Factory Cleanup Contract:**
    - createHeadlessEditor(buffer) returns an object with `editor` and `cleanup` properties
    - `editor` is a truthy object (the SuperDoc editor instance)
    - `cleanup` is a function
    - Calling cleanup() does not throw
    - After cleanup(), editor.destroy() has been called (editor is no longer usable)

    **Concurrency Limiter Integration:**
    - App instance has `documentSemaphore` decorator after ready()
    - documentSemaphore has `acquire()` and `release()` methods
    - When MAX_DOCUMENT_CONCURRENCY is set, it uses that value (test with custom app option)

    **Read Endpoint with Resource Management:**
    - Successful POST /v1/read still returns 200 with IR (existing behavior preserved)
    - Error responses (422 EXTRACTION_FAILED) do not deadlock the semaphore (subsequent requests still work)
    - Multiple sequential successful requests work (semaphore is properly released each time)
    - After a failed request, subsequent successful requests still work (no semaphore leak)

    Cases:
    - createHeadlessEditor(validBuffer) -> { editor: object, cleanup: function }
    - cleanup() -> no throw, editor destroyed
    - app.documentSemaphore -> truthy with acquire/release methods
    - POST /v1/read with valid DOCX x3 sequential -> all return 200 (semaphore released each time)
    - POST /v1/read with corrupt DOCX then valid DOCX -> 422 then 200 (error cleanup works)
  </behavior>
  <implementation>
    Create `tests_and_others/tests/resource-management.test.mjs` with Node.js built-in test runner (node:test).

    Test structure (4 suites):

    **Suite 1: Editor Factory Cleanup Contract**
    - Uses a valid DOCX fixture (same as read.test.mjs: tests_and_others/tests/fixtures/sample.docx)
    - Tests createHeadlessEditor returns {editor, cleanup}
    - Tests cleanup is callable without throwing

    **Suite 2: Concurrency Limiter Plugin**
    - Creates app with buildApp({ logger: false, apiKey: 'test-key' })
    - After ready(), checks app.documentSemaphore exists
    - Verifies acquire() and release() are functions

    **Suite 3: Sequential Request Resource Lifecycle**
    - Creates app, loads sample DOCX
    - Sends 3 sequential valid requests to POST /v1/read - all should return 200
    - This proves semaphore is released after each request (if leaked, 4th+ would hang)
    - Uses the buildMultipartPayload helper from read.test.mjs (copy it)

    **Suite 4: Error Path Cleanup**
    - Sends a request with corrupted DOCX (valid ZIP, invalid DOCX content) -> 422
    - Immediately sends a valid DOCX request -> 200
    - This proves the error path properly releases the semaphore and cleans up

    Use the same test patterns as read.test.mjs: separate app per describe block, before/after hooks, buildMultipartPayload helper.
  </implementation>
</feature>

<verification>
1. `node --test tests_and_others/tests/resource-management.test.mjs` - All resource management tests pass
2. `node --test tests_and_others/tests/read.test.mjs` - Existing read tests still pass
3. `node --test tests_and_others/tests/server.test.mjs` - Server tests still pass
</verification>

<success_criteria>
- All 4 test suites pass covering: editor factory cleanup, concurrency limiter, sequential requests, error path cleanup
- Tests prove semaphore is released on both success and error paths (no deadlock)
- Tests prove cleanup function works without throwing
- Existing read.test.mjs tests remain green
</success_criteria>

<output>
After completion, create `.planning/phases/05-resource-management/05-02-SUMMARY.md`
</output>
