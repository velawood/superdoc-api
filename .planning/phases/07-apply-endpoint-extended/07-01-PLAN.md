---
phase: 07-apply-endpoint-extended
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/routes/apply.mjs
autonomous: true

must_haves:
  truths:
    - "POST /v1/apply with markdown-formatted edits auto-detects the format and applies edits identically to JSON input"
    - "POST /v1/apply?dry_run=true returns a JSON validation report without producing a DOCX file"
    - "Successful apply responses include X-Edits-Applied, X-Edits-Skipped, and X-Warnings headers with accurate counts"
    - "Malformed markdown edits return 400 INVALID_EDITS_MARKDOWN with descriptive error"
    - "Dry-run returns 200 even when validation finds invalid edits (valid: false in body)"
    - "Header values are stringified integers matching validation.summary counts"
  artifacts:
    - path: "src/routes/apply.mjs"
      provides: "Extended apply route with markdown format detection, dry-run mode, and edit summary headers"
      contains: "parseMarkdownEdits"
  key_links:
    - from: "src/routes/apply.mjs"
      to: "src/markdownEditsParser.mjs"
      via: "import parseMarkdownEdits for markdown format support"
      pattern: "import.*parseMarkdownEdits.*from.*markdownEditsParser"
    - from: "src/routes/apply.mjs"
      to: "src/editApplicator.mjs"
      via: "validateEditsAgainstIR provides summary counts for headers and dry-run report"
      pattern: "validation\\.summary"
---

<objective>
Extend the POST /v1/apply route handler with three capabilities: (1) markdown edit format auto-detection and parsing, (2) dry-run validation mode via query parameter, and (3) edit summary response headers.

Purpose: Complete APPLY-05, APPLY-06, APPLY-07 requirements by extending the existing apply route from Phase 6 with format flexibility, validation-only mode, and response metadata.
Output: Updated src/routes/apply.mjs with all three features integrated into the existing handler flow.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-apply-endpoint-extended/07-RESEARCH.md
@.planning/phases/06-apply-endpoint-core/06-02-SUMMARY.md
@src/routes/apply.mjs
@src/markdownEditsParser.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add markdown format auto-detection and dry-run query param schema</name>
  <files>src/routes/apply.mjs</files>
  <action>
Extend src/routes/apply.mjs with the following changes:

1. Add import at top of file:
   `import { parseMarkdownEdits } from "../markdownEditsParser.mjs";`

2. Add route schema for query parameter validation. Change the route definition from:
   `fastify.post("/apply", { preHandler: [requireMultipart] }, ...)`
   to:
   ```javascript
   fastify.post("/apply", {
     preHandler: [requireMultipart],
     schema: {
       querystring: {
         type: 'object',
         properties: {
           dry_run: { type: 'boolean', default: false }
         }
       }
     }
   }, ...)
   ```

3. Add `isDryRun` flag at the top of the handler:
   `const isDryRun = request.query.dry_run === true;`
   Note: With Fastify schema coercion, type: 'boolean' handles string-to-boolean conversion, so checking `=== true` is sufficient.

4. Replace the edits parsing block (the `if (part.fieldname === "edits")` section) with format auto-detection:
   ```javascript
   if (part.fieldname === "edits") {
     const editsString = part.value;
     const trimmed = editsString.trim();

     // Auto-detect markdown format via anchored marker patterns
     const isMarkdown = trimmed.startsWith('# Edits')
       || trimmed.startsWith('## Metadata')
       || trimmed.startsWith('## Edits Table')
       || /^\|\s*Block\s*\|/.test(trimmed);

     if (isMarkdown) {
       const parsed = parseMarkdownEdits(editsString);
       if (!parsed || !parsed.edits || !Array.isArray(parsed.edits) || parsed.edits.length === 0) {
         return reply.status(400).send(buildError(
           "INVALID_EDITS_MARKDOWN",
           "Markdown format detected but parsing failed or contains no edits",
           [{ field: "edits", reason: "Could not parse markdown edits table" }]
         ));
       }
       editsJson = parsed.edits;
     } else {
       try {
         editsJson = JSON.parse(editsString);
       } catch (error) {
         return reply.status(400).send(buildError(
           "INVALID_EDITS_JSON",
           "Edits field must be valid JSON or markdown format",
           [{ field: "edits", reason: error.message }]
         ));
       }
     }
   }
   ```
   Key: Detection uses anchored patterns (startsWith) so JSON strings containing "# Edits" as a value won't false-positive. The table header regex is also anchored with `^`.
   Key: Always use API_AUTHOR, ignore markdown author metadata (defer to v2 FEAT-02).

5. Update the MISSING_EDITS error message to mention markdown format:
   Change "Edits field is required and must be a JSON array" to
   "Edits field is required and must be a JSON array or markdown format"
  </action>
  <verify>
Run: `node -e "import('./src/routes/apply.mjs').then(m => console.log('apply route:', typeof m.default))"`
Confirm output: `apply route: function`

Run: `grep -c "parseMarkdownEdits" src/routes/apply.mjs`
Confirm output is at least 2 (import + usage).

Run: `grep "INVALID_EDITS_MARKDOWN" src/routes/apply.mjs`
Confirm the markdown error code exists.

Run: `grep "dry_run" src/routes/apply.mjs`
Confirm the query schema and isDryRun flag exist.
  </verify>
  <done>apply.mjs imports parseMarkdownEdits, auto-detects markdown vs JSON via anchored pattern matching, and has dry_run query parameter in the route schema</done>
</task>

<task type="auto">
  <name>Task 2: Add dry-run early-exit and edit summary response headers</name>
  <files>src/routes/apply.mjs</files>
  <action>
Continue editing src/routes/apply.mjs to add the dry-run response and summary headers:

1. After the `const validation = validateEditsAgainstIR(editsJson, ir);` line and BEFORE the `if (!validation.valid)` check, insert the dry-run early-exit:
   ```javascript
   // Dry-run mode: return validation report without applying edits
   if (isDryRun) {
     return reply.type('application/json').send({
       valid: validation.valid,
       summary: {
         totalEdits: validation.summary.totalEdits,
         validEdits: validation.summary.validEdits,
         invalidEdits: validation.summary.invalidEdits,
         warningCount: validation.summary.warningCount
       },
       issues: validation.issues.map(issue => ({
         editIndex: issue.editIndex,
         blockId: issue.blockId ?? null,
         type: issue.type,
         message: issue.message
       })),
       warnings: (validation.warnings || []).map(warn => ({
         editIndex: warn.editIndex,
         blockId: warn.blockId ?? null,
         type: warn.type,
         message: warn.message
       }))
     });
   }
   ```
   Key: Returns 200 regardless of validation.valid value. The request succeeded (dry-run performed); edits being invalid is reported in the body, not the HTTP status.
   Key: Use `(validation.warnings || [])` defensively in case warnings is undefined.

2. Add summary headers to the successful response. Replace the final return block (the one with Content-Type and Content-Disposition) with:
   ```javascript
   const appliedCount = validation.summary.validEdits;
   const skippedCount = validation.summary.invalidEdits;
   const warningCount = validation.summary.warningCount;

   const outputFilename = sanitizeOutputFilename(filename);
   return reply
     .header("Content-Type", DOCX_CONTENT_TYPE)
     .header("Content-Disposition", `attachment; filename="${outputFilename}"`)
     .header("X-Edits-Applied", String(appliedCount))
     .header("X-Edits-Skipped", String(skippedCount))
     .header("X-Warnings", String(warningCount))
     .send(finalBuffer);
   ```
   Key: Header values MUST be strings (use String()). Headers only on success (200), not error responses.
   Key: Use validation.summary counts, not runtime skip tracking. validation.summary.invalidEdits will be 0 when all edits are valid (since we reject on !validation.valid in normal mode). The header is still useful when future strictness modes allow partial application.

3. Update the JSDoc comment at the top of applyRoutes to document the new capabilities:
   - Add to docstring: markdown format support for edits field, dry_run query parameter, and X-Edits-Applied/X-Edits-Skipped/X-Warnings response headers.
   - Add error code: 400 INVALID_EDITS_MARKDOWN
  </action>
  <verify>
Run: `grep "isDryRun" src/routes/apply.mjs`
Confirm the dry-run check exists.

Run: `grep "X-Edits-Applied" src/routes/apply.mjs`
Confirm the summary header exists.

Run: `grep "X-Edits-Skipped" src/routes/apply.mjs`
Confirm the summary header exists.

Run: `grep "X-Warnings" src/routes/apply.mjs`
Confirm the summary header exists.

Run all existing tests to ensure no regressions:
`node --test tests_and_others/tests/server.test.mjs`
`node --test tests_and_others/tests/auth.test.mjs`
`node --test tests_and_others/tests/read.test.mjs`
  </verify>
  <done>Dry-run returns 200 JSON validation report (with valid/summary/issues/warnings fields), successful apply responses include X-Edits-Applied/X-Edits-Skipped/X-Warnings headers with stringified counts, all existing tests pass</done>
</task>

</tasks>

<verification>
1. `node -e "import('./src/routes/apply.mjs').then(m => console.log('OK:', typeof m.default))"` -> OK: function
2. `grep "parseMarkdownEdits" src/routes/apply.mjs` -> shows import and usage
3. `grep "dry_run" src/routes/apply.mjs` -> shows schema and isDryRun
4. `grep "X-Edits-Applied" src/routes/apply.mjs` -> shows header
5. `grep "INVALID_EDITS_MARKDOWN" src/routes/apply.mjs` -> shows error code
6. All existing test suites pass with no regressions
</verification>

<success_criteria>
- src/routes/apply.mjs imports parseMarkdownEdits and auto-detects markdown vs JSON format
- Markdown detection uses anchored patterns (no false positives on JSON)
- Malformed markdown returns 400 INVALID_EDITS_MARKDOWN
- Route schema defines dry_run boolean query parameter
- isDryRun triggers early-exit with JSON validation report (200 status always)
- Successful apply responses include X-Edits-Applied, X-Edits-Skipped, X-Warnings as string headers
- All existing tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/07-apply-endpoint-extended/07-01-SUMMARY.md`
</output>
