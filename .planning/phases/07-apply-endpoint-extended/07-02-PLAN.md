---
phase: 07-apply-endpoint-extended
plan: 02
type: tdd
wave: 2
depends_on: ["07-01"]
files_modified:
  - tests_and_others/tests/apply-extended.test.mjs
autonomous: true

must_haves:
  truths:
    - "Tests verify markdown edits are auto-detected and applied identically to JSON edits"
    - "Tests verify malformed markdown returns 400 INVALID_EDITS_MARKDOWN"
    - "Tests verify dry_run=true returns 200 JSON validation report (not DOCX binary)"
    - "Tests verify dry_run=true returns 200 even when edits are invalid (valid: false)"
    - "Tests verify successful apply response includes X-Edits-Applied, X-Edits-Skipped, X-Warnings headers"
    - "Tests verify header values are accurate string integers matching edit counts"
  artifacts:
    - path: "tests_and_others/tests/apply-extended.test.mjs"
      provides: "Contract tests for markdown format, dry-run mode, and edit summary headers"
      min_lines: 100
  key_links:
    - from: "tests_and_others/tests/apply-extended.test.mjs"
      to: "src/app.mjs"
      via: "import buildApp for fastify.inject() testing"
      pattern: "buildApp"
    - from: "tests_and_others/tests/apply-extended.test.mjs"
      to: "src/routes/apply.mjs"
      via: "Tests exercise extended apply route features via HTTP"
      pattern: "/v1/apply"
---

<objective>
Create contract tests for the Phase 7 apply endpoint extensions: markdown format auto-detection, dry-run validation mode, and edit summary response headers.

Purpose: Verify APPLY-05, APPLY-06, APPLY-07 requirements work correctly via HTTP-level contract tests. Tests prove markdown edits produce identical results to JSON, dry-run returns validation reports without DOCX, and headers contain accurate counts.
Output: tests_and_others/tests/apply-extended.test.mjs with comprehensive test coverage.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-apply-endpoint-extended/07-RESEARCH.md
@.planning/phases/07-apply-endpoint-extended/07-01-SUMMARY.md
@src/routes/apply.mjs
@src/markdownEditsParser.mjs
@tests_and_others/tests/read.test.mjs
@tests_and_others/tests/auth.test.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test file with markdown format detection and parsing tests</name>
  <files>tests_and_others/tests/apply-extended.test.mjs</files>
  <action>
Create tests_and_others/tests/apply-extended.test.mjs following the established test patterns from read.test.mjs and auth.test.mjs:

**Test infrastructure:**
- Import `{ describe, it, before, after }` from `node:test` and `{ strict as assert }` from `node:assert`.
- Import `buildApp` from `../../src/app.mjs`.
- Import `{ editsToMarkdown }` from `../../src/markdownEditsParser.mjs` for generating valid markdown from JSON edits.
- Use the same fixture loading pattern as read.test.mjs (read a real .docx file from tests_and_others/tests/fixtures/).
- Create app instance in `before()` with `{ logger: false, apiKey: 'test-key' }` and close in `after()`.
- Define a helper function `makeApplyRequest(app, { file, edits, querystring, contentType })` that builds a multipart/form-data payload with file and edits fields and calls `app.inject()` on POST /v1/apply with Bearer auth header.

**Markdown format auto-detection tests (APPLY-05):**

1. "accepts markdown-formatted edits and returns 200 with DOCX binary"
   - Create a valid JSON edits array (e.g., a simple replace edit targeting a known block ID in the test fixture).
   - Convert to markdown using `editsToMarkdown(edits, { author: { name: 'Test', email: 'test@test.com' } })`.
   - Send to /v1/apply with markdown string as the edits field.
   - Assert response status is 200.
   - Assert Content-Type is the DOCX MIME type.
   - Assert response body is a Buffer with PK magic bytes (ZIP/DOCX).

2. "returns 400 INVALID_EDITS_MARKDOWN for malformed markdown"
   - Send edits field with value `"# Edits\n\nThis is not a valid edits table"` (has markdown markers but no parseable table).
   - Assert response status is 400.
   - Assert response body error.code is "INVALID_EDITS_MARKDOWN".

3. "auto-detects JSON when edits field is valid JSON array"
   - Send a valid JSON array string as edits field.
   - Assert response processes normally (not treated as markdown).
   - This test verifies JSON does not false-positive as markdown.

4. "auto-detects JSON when edits field starts with [ (array notation)"
   - Send `'[{"blockId":"b1","operation":"delete","comment":"test"}]'` as edits.
   - Assert it is parsed as JSON (no INVALID_EDITS_MARKDOWN error).

**Note on test fixture:** Use the same DOCX test fixture as the read endpoint tests (or the apply test fixture if one exists from Phase 6). To create edits that will pass validation, first call POST /v1/read to extract IR from the test fixture, then construct edits referencing real block IDs from the IR. If this approach is too complex, use dry_run=true to test format detection (since dry_run returns validation report regardless of edit validity, you can use fake block IDs for format detection tests and check the response structure rather than 200 with DOCX).
  </action>
  <verify>
Run: `node --test tests_and_others/tests/apply-extended.test.mjs`
All markdown format tests pass.
  </verify>
  <done>Markdown format auto-detection tests pass: valid markdown accepted, malformed markdown returns 400, JSON not false-detected as markdown</done>
</task>

<task type="auto">
  <name>Task 2: Add dry-run mode and response header tests</name>
  <files>tests_and_others/tests/apply-extended.test.mjs</files>
  <action>
Add the following test suites to the existing test file:

**Dry-run mode tests (APPLY-06):**

1. "dry_run=true returns 200 with JSON validation report"
   - Send a valid DOCX + edits (JSON) with `?dry_run=true` query string.
   - Assert response status is 200.
   - Assert Content-Type is application/json (not DOCX binary).
   - Assert response body has `valid`, `summary`, `issues`, `warnings` fields.
   - Assert `summary` has `totalEdits`, `validEdits`, `invalidEdits`, `warningCount` fields.

2. "dry_run=true returns 200 even with invalid edits"
   - Send a DOCX + edits with invalid block IDs and `?dry_run=true`.
   - Assert response status is 200 (NOT 400).
   - Assert response body `valid` is false.
   - Assert `issues` array is non-empty.
   - Assert `summary.invalidEdits` > 0.

3. "dry_run=true does not return DOCX binary"
   - Send a dry-run request.
   - Assert response body is JSON (parseable object).
   - Assert response body does NOT start with PK magic bytes (is not a DOCX).

4. "dry_run=false (or absent) returns DOCX binary as usual"
   - Send a normal apply request without dry_run param.
   - Assert response is DOCX binary (status 200, Content-Type is DOCX).

5. "dry_run=true works with markdown-formatted edits"
   - Send markdown-formatted edits with dry_run=true.
   - Assert response is JSON validation report (not 400, not DOCX).
   - This verifies markdown + dry-run combination works.

**Response header tests (APPLY-07):**

6. "successful apply includes X-Edits-Applied header"
   - Send a valid apply request (valid DOCX + valid edits).
   - Assert response status is 200.
   - Assert response headers contain `x-edits-applied` (headers are lowercase in Fastify).
   - Assert the value is a string integer >= 0.

7. "successful apply includes X-Edits-Skipped header"
   - Same request as above.
   - Assert response headers contain `x-edits-skipped`.
   - Assert the value is a string integer (likely "0" for all-valid edits).

8. "successful apply includes X-Warnings header"
   - Same request as above.
   - Assert response headers contain `x-warnings`.
   - Assert the value is a string integer >= 0.

9. "header counts match edit summary"
   - Send a request with N valid edits.
   - Assert `parseInt(response.headers['x-edits-applied'])` equals N.
   - Assert `parseInt(response.headers['x-edits-skipped'])` equals 0.

10. "error responses do NOT include edit summary headers"
    - Send a request that returns 400 (e.g., missing file).
    - Assert response headers do NOT contain `x-edits-applied`.

**Testing strategy for valid edits:** To get a 200 response with DOCX binary (needed for header tests), you need edits that pass validation against the test fixture's IR. The recommended approach:
- Use the same test fixture DOCX as read.test.mjs.
- Either: (a) hardcode a known block ID from the fixture (inspect read output), or (b) in a before() hook, call /v1/read to get IR, extract a real block ID, then use that block ID in edits for the apply tests.
- If getting valid edits is difficult, focus dry-run tests (which don't need valid edits) and header tests on confirming header presence/format even if the exact counts vary.
  </action>
  <verify>
Run: `node --test tests_and_others/tests/apply-extended.test.mjs`
All tests pass.

Run all existing test suites to verify no regressions:
`node --test tests_and_others/tests/server.test.mjs`
`node --test tests_and_others/tests/auth.test.mjs`
`node --test tests_and_others/tests/read.test.mjs`
  </verify>
  <done>All apply-extended tests pass: dry-run returns JSON report with correct structure, dry-run returns 200 on invalid edits, successful apply responses include X-Edits-Applied/X-Edits-Skipped/X-Warnings headers with accurate counts, error responses exclude summary headers, all existing tests still pass</done>
</task>

</tasks>

<verification>
1. `node --test tests_and_others/tests/apply-extended.test.mjs` -> all tests pass
2. `node --test tests_and_others/tests/server.test.mjs` -> no regressions
3. `node --test tests_and_others/tests/auth.test.mjs` -> no regressions
4. `node --test tests_and_others/tests/read.test.mjs` -> no regressions
</verification>

<success_criteria>
- Markdown format detection tests: valid markdown accepted, malformed rejected with INVALID_EDITS_MARKDOWN, JSON not false-detected
- Dry-run tests: returns 200 JSON report with valid/summary/issues/warnings, returns 200 even for invalid edits, does not return DOCX binary
- Header tests: X-Edits-Applied, X-Edits-Skipped, X-Warnings present on 200 responses as string integers, absent on error responses
- All existing test suites pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/07-apply-endpoint-extended/07-02-SUMMARY.md`
</output>
