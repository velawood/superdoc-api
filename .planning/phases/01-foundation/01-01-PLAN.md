---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/app.mjs
  - src/server.mjs
  - src/routes/health.mjs
  - src/plugins/request-id.mjs
  - src/plugins/error-handler.mjs
autonomous: true

must_haves:
  truths:
    - "GET /health returns {status:ok} with HTTP 200"
    - "GET /v1/health returns {status:ok} with HTTP 200"
    - "Every response includes X-Request-Id header"
    - "Client-provided X-Request-Id is echoed back"
    - "Unknown routes return 404 with structured error JSON"
    - "Server errors return 500 with safe error message (no internals leaked)"
    - "Validation errors return 400 with field-level details"
    - "All API endpoints are mounted under /v1/ prefix"
  artifacts:
    - path: "src/app.mjs"
      provides: "Fastify app factory with plugin registration"
      exports: ["default (buildApp)"]
    - path: "src/server.mjs"
      provides: "Server entry point that calls listen()"
    - path: "src/routes/health.mjs"
      provides: "GET /health route handler"
      exports: ["default (healthRoutes plugin)"]
    - path: "src/plugins/request-id.mjs"
      provides: "onSend hook echoing X-Request-Id"
      exports: ["default (requestIdPlugin)"]
    - path: "src/plugins/error-handler.mjs"
      provides: "setErrorHandler + setNotFoundHandler"
      exports: ["default (errorHandlerPlugin)"]
  key_links:
    - from: "src/app.mjs"
      to: "src/plugins/request-id.mjs"
      via: "app.register(requestIdPlugin)"
      pattern: "register.*requestId"
    - from: "src/app.mjs"
      to: "src/plugins/error-handler.mjs"
      via: "app.register(errorHandlerPlugin)"
      pattern: "register.*errorHandler"
    - from: "src/app.mjs"
      to: "src/routes/health.mjs"
      via: "app.register(healthRoutes, { prefix: '/v1' })"
      pattern: "register.*health.*prefix.*v1"
    - from: "src/server.mjs"
      to: "src/app.mjs"
      via: "import buildApp, call app.listen()"
      pattern: "import.*buildApp.*from.*app"
---

<objective>
Bootstrap the Fastify 5 server with health check, request ID tracing, structured error handling, and /v1/ API versioning.

Purpose: Establish the HTTP server foundation that all future phases build on. This is the skeleton that receives requests, traces them, routes them, and formats errors consistently.

Output: A running Fastify server with app factory pattern (testable via inject), health endpoint at /health and /v1/health, X-Request-Id on every response, structured JSON errors, and correct HTTP status codes.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and configure project</name>
  <files>package.json</files>
  <action>
Install fastify and pino-pretty:
```bash
npm install fastify
npm install -D pino-pretty
```

Update package.json:
1. Change engines.node from ">=18.0.0" to ">=20.0.0" (Fastify 5 requires Node.js 20+, research verified this)
2. Add a "start" script: "node src/server.mjs"
3. Add a "dev" script: "node src/server.mjs | npx pino-pretty" (human-readable logs in development)

Do NOT modify existing scripts (test, redline). Do NOT change any existing dependencies.
  </action>
  <verify>
```bash
node -e "import('fastify').then(m => console.log('fastify OK'))"
npm ls fastify
npm ls pino-pretty
node -e "const pkg = JSON.parse(require('fs').readFileSync('package.json')); console.log(pkg.engines.node); console.assert(pkg.engines.node === '>=20.0.0')"
```
  </verify>
  <done>fastify is in dependencies, pino-pretty is in devDependencies, engines.node is >=20.0.0, start and dev scripts exist</done>
</task>

<task type="auto">
  <name>Task 2: Create server source files</name>
  <files>
    src/app.mjs
    src/server.mjs
    src/routes/health.mjs
    src/plugins/request-id.mjs
    src/plugins/error-handler.mjs
  </files>
  <action>
Create 5 files following the app factory pattern from research. Use the exact patterns verified in 01-RESEARCH.md. Follow existing codebase conventions: .mjs extension, 2-space indentation, double quotes, semicolons, JSDoc for exports, camelCase naming.

**src/plugins/request-id.mjs** - onSend hook plugin:
- Add an onSend hook that sets `X-Request-Id` response header to `request.id`
- MUST return payload from the hook (Pitfall 2 from research: not returning payload causes empty responses)
- Export as default async plugin function

**src/plugins/error-handler.mjs** - Error formatting plugin:
- setNotFoundHandler: returns 404 with `{error: {code: "NOT_FOUND", message: "Route METHOD URL not found", details: []}}`
- setErrorHandler: handles three cases:
  1. Validation errors (error.validation exists): return 400 with code "VALIDATION_ERROR", details array mapping each validation issue to `{field, message}`
  2. Errors with statusCode set: use that statusCode, return error.message for 4xx, generic "An internal server error occurred" for 5xx
  3. Everything else: return 500 with code "INTERNAL_ERROR" and generic message
- Always call `reply.status(statusCode)` explicitly before `reply.send()` (Pitfall 3 from research)
- Log errors via `request.log.error(error)` in the error handler
- Export as default async plugin function

**src/routes/health.mjs** - Health check route:
- GET /health returning `{status: "ok"}`
- Simple async handler, no dependencies on SuperDoc or JSDOM
- Export as default async plugin function

**src/app.mjs** - App factory:
- Export default function `buildApp(opts = {})` that creates and returns a configured Fastify instance
- Fastify options:
  - `logger`: Use `opts.logger` if provided (allows tests to pass `false`), otherwise `{level: process.env.LOG_LEVEL || "info"}`
  - `requestIdHeader: "x-request-id"` (Fastify reads this header from incoming requests)
  - `genReqId: () => crypto.randomUUID()` (generates UUID when no client header)
- Register plugins: requestIdPlugin, errorHandlerPlugin
- Register health route at root: `app.register(healthRoutes)` (for infrastructure probes at /health)
- Register health route under v1: `app.register(healthRoutes, { prefix: "/v1" })` (for API consistency)
- Import crypto from "node:crypto"
- Return the app instance (do NOT call listen or ready)

**src/server.mjs** - Entry point:
- Import buildApp from "./app.mjs"
- Create app instance with `buildApp()`
- Call `app.listen({ port: parseInt(process.env.PORT || "3000", 10), host: "0.0.0.0" })`
- On success: log the listening address (Fastify logs this automatically)
- On error: log via `app.log.error(err)` and `process.exit(1)`
- Use top-level await (ESM supports this)
  </action>
  <verify>
```bash
# Server starts and responds
timeout 5 node src/server.mjs &
SERVER_PID=$!
sleep 2

# Health check works
curl -s http://localhost:3000/health | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.assert(d.status==='ok', 'health check failed'); console.log('health OK')"

# v1 health works
curl -s http://localhost:3000/v1/health | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.assert(d.status==='ok', 'v1 health check failed'); console.log('v1 health OK')"

# Request ID present
curl -sI http://localhost:3000/health | grep -i x-request-id

# 404 is structured
curl -s http://localhost:3000/nonexistent | node -e "const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.assert(d.error.code==='NOT_FOUND', '404 format wrong'); console.log('404 OK')"

kill $SERVER_PID 2>/dev/null
```
  </verify>
  <done>
All 5 source files exist. Server starts on port 3000. GET /health and GET /v1/health return {"status":"ok"} with 200. Every response has X-Request-Id header. Unknown routes return structured 404 JSON. Error responses use correct HTTP status codes.
  </done>
</task>

</tasks>

<verification>
Run all checks in sequence:

1. `npm ls fastify` shows fastify@5.x installed
2. `node -e "import('./src/app.mjs').then(m => { const app = m.default({logger:false}); app.inject({method:'GET',url:'/health'}).then(r => { console.log(r.statusCode, r.body); console.assert(r.statusCode===200) }) })"` - health check via inject
3. Start server, curl /health, /v1/health, /nonexistent - all return expected responses with X-Request-Id
4. No SuperDoc or JSDOM imports in any of the new files (grep confirms)
</verification>

<success_criteria>
- GET /health returns {"status":"ok"} with HTTP 200
- GET /v1/health returns {"status":"ok"} with HTTP 200
- Every HTTP response includes X-Request-Id header (UUID format)
- Client-provided X-Request-Id header is echoed back in response
- GET /nonexistent returns 404 with {error:{code:"NOT_FOUND", message:"...", details:[]}}
- Server starts via `node src/server.mjs` without errors
- No dependency on SuperDoc, JSDOM, or any domain modules
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
