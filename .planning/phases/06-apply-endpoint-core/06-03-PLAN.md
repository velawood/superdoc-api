---
phase: 06-apply-endpoint-core
plan: 03
type: tdd
wave: 3
depends_on: ["06-02"]
files_modified:
  - tests_and_others/tests/apply.test.mjs
autonomous: true

must_haves:
  truths:
    - "Tests verify POST /v1/apply with valid DOCX + valid edits returns 200 with DOCX binary"
    - "Tests verify response has correct Content-Type and Content-Disposition headers"
    - "Tests verify invalid edits return 400 with full validation error list (APPLY-02)"
    - "Tests verify missing file returns 400 MISSING_FILE"
    - "Tests verify missing edits returns 400 MISSING_EDITS"
    - "Tests verify malformed JSON edits returns 400 INVALID_EDITS_JSON"
    - "Tests verify non-DOCX file returns 400 INVALID_FILE_TYPE"
    - "Tests verify auth is required (401 without Bearer token)"
  artifacts:
    - path: "tests_and_others/tests/apply.test.mjs"
      provides: "Comprehensive contract tests for POST /v1/apply endpoint"
      min_lines: 150
  key_links:
    - from: "tests_and_others/tests/apply.test.mjs"
      to: "src/app.mjs"
      via: "import buildApp for fastify.inject() testing"
      pattern: "buildApp"
    - from: "tests_and_others/tests/apply.test.mjs"
      to: "src/routes/apply.mjs"
      via: "Tests exercise apply route via HTTP requests"
      pattern: "/v1/apply"
---

<objective>
Create comprehensive contract tests for the POST /v1/apply endpoint covering happy path, validation errors, input validation, auth, and content-type checks.

Purpose: Verify that the apply endpoint correctly handles all request variations defined in APPLY-01 through APPLY-04. Tests prove the endpoint rejects invalid input with proper error codes and successfully processes valid DOCX + edits into a redlined document.

Output: Test file proving all apply endpoint behaviors via fastify.inject().
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-apply-endpoint-core/06-02-SUMMARY.md

@src/routes/apply.mjs
@src/app.mjs
@tests_and_others/tests/read.test.mjs
@tests_and_others/tests/auth.test.mjs
</context>

<feature>
  <name>Apply Endpoint Contract Tests</name>
  <files>tests_and_others/tests/apply.test.mjs</files>
  <behavior>
    Expected behavior in testable terms:

    **Happy Path:**
    - POST /v1/apply with valid DOCX + valid JSON edits array + Bearer token returns HTTP 200
    - Response Content-Type is application/vnd.openxmlformats-officedocument.wordprocessingml.document
    - Response Content-Disposition contains "attachment" and filename ending in "-edited.docx"
    - Response body is a Buffer (non-empty binary data)
    - Response body starts with ZIP magic bytes (PK\x03\x04) confirming valid DOCX

    **Edit Validation (APPLY-02):**
    - Edits referencing non-existent block IDs return 400 INVALID_EDITS
    - Response details array contains one entry per invalid edit with editIndex, blockId, type, message
    - Replace edit missing newText returns 400 INVALID_EDITS with missing_field type
    - Mix of valid and invalid edits: entire request rejected (no partial application)

    **Input Validation:**
    - No file field -> 400 MISSING_FILE
    - No edits field -> 400 MISSING_EDITS
    - Edits field is not an array (e.g., string, object) -> 400 MISSING_EDITS
    - Malformed JSON in edits field -> 400 INVALID_EDITS_JSON
    - Non-DOCX file (PNG magic bytes) -> 400 INVALID_FILE_TYPE

    **Auth:**
    - No Authorization header -> 401
    - Invalid Bearer token -> 401

    **Content-Type:**
    - Non-multipart Content-Type -> 400 INVALID_CONTENT_TYPE

    Cases:
    - POST /v1/apply (valid DOCX + comment edit) -> 200 + DOCX binary
    - POST /v1/apply (valid DOCX + [{ blockId: "nonexistent", operation: "replace", newText: "x" }]) -> 400 INVALID_EDITS
    - POST /v1/apply (valid DOCX + [{ blockId: "b001", operation: "replace" }]) -> 400 INVALID_EDITS (missing newText)
    - POST /v1/apply (no file) -> 400 MISSING_FILE
    - POST /v1/apply (no edits) -> 400 MISSING_EDITS
    - POST /v1/apply (edits: "not json") -> 400 INVALID_EDITS_JSON
    - POST /v1/apply (PNG file + valid edits) -> 400 INVALID_FILE_TYPE
    - POST /v1/apply (no auth) -> 401
    - POST /v1/apply (wrong Content-Type) -> 400 INVALID_CONTENT_TYPE
  </behavior>
  <implementation>
    Create `tests_and_others/tests/apply.test.mjs` using Node.js built-in test runner (node:test).

    **Setup (follow patterns from read.test.mjs and auth.test.mjs):**

    1. Import: `describe, it, before, after` from `node:test`, `assert` from `node:assert/strict`, `buildApp` from `../../src/app.mjs`, `readFile` from `fs/promises`, `path`, `fileURLToPath`.

    2. Helper function `buildMultipartPayload(parts)`:
       Builds a multipart/form-data payload with boundary. Each part can be:
       - `{ fieldname, filename, content, contentType }` for file fields
       - `{ fieldname, value }` for text fields (edits JSON)
       Build the multipart body with proper boundary, Content-Disposition, and Content-Type headers for each part. Return `{ body: Buffer, contentType: 'multipart/form-data; boundary=...' }`.

       Copy and adapt the helper from read.test.mjs if it exists. For the edits field, it must be sent as a text field (not file).

    3. Load a real DOCX fixture: `tests_and_others/tests/fixtures/sample.docx` (same fixture used in read tests).

    4. To get valid block IDs for testing: In the `before()` hook, first send a POST /v1/read request to get the document IR, then extract a valid blockId from the response. Use this blockId for happy path edits.

    **Test Suites (5 suites):**

    **Suite 1: Happy Path**
    - Create app with buildApp({ logger: false, apiKey: 'test-key' })
    - Load sample.docx, get valid blockId via /v1/read
    - Test: POST /v1/apply with DOCX file + `[{ blockId, operation: "comment", comment: "Test comment" }]` -> 200
    - Verify Content-Type header is DOCX MIME type
    - Verify Content-Disposition contains "attachment" and "-edited.docx"
    - Verify response body is non-empty Buffer starting with PK\x03\x04 (ZIP magic bytes)

    **Suite 2: Edit Validation (APPLY-02)**
    - Test: Edits with non-existent blockId -> 400, code: "INVALID_EDITS", details array with missing_block type
    - Test: Replace edit without newText -> 400, code: "INVALID_EDITS", details array with missing_field type
    - Verify details array length matches number of invalid edits
    - Verify each detail has editIndex, blockId, type, message fields

    **Suite 3: Input Validation**
    - Test: Only edits field, no file -> 400 MISSING_FILE
    - Test: Only file, no edits field -> 400 MISSING_EDITS
    - Test: Edits field with invalid JSON string -> 400 INVALID_EDITS_JSON
    - Test: Edits field is JSON object (not array) -> 400 MISSING_EDITS
    - Test: PNG magic bytes file -> 400 INVALID_FILE_TYPE

    **Suite 4: Authentication**
    - Test: No Authorization header -> 401
    - Test: Wrong Bearer token -> 401

    **Suite 5: Content-Type**
    - Test: application/json Content-Type -> 400 INVALID_CONTENT_TYPE

    **Testing notes:**
    - Use separate app instance per suite (before/after hooks)
    - For PNG test: create a 100-byte buffer starting with PNG magic bytes `\x89PNG`
    - For missing file test: send multipart with only the edits text field
    - For missing edits test: send multipart with only the file field
    - For invalid JSON test: send edits field with value `"not valid json {"`
    - The comment operation is the simplest valid edit type (no newText needed, no document modification risk)
    - Use `assert.equal(response.statusCode, ...)` for status checks
    - Parse JSON error bodies with `JSON.parse(response.body)` or `response.json()`
  </implementation>
</feature>

<verification>
1. `node --test tests_and_others/tests/apply.test.mjs` - All apply endpoint tests pass
2. `node --test tests_and_others/tests/read.test.mjs` - Read tests still pass
3. `node --test tests_and_others/tests/server.test.mjs` - Server tests still pass
4. `node --test tests_and_others/tests/auth.test.mjs` - Auth tests still pass
</verification>

<success_criteria>
- All 5 test suites pass covering: happy path, edit validation, input validation, auth, content-type
- Happy path test confirms 200 response with valid DOCX binary (ZIP magic bytes present)
- APPLY-02 test confirms full validation error list in details array
- Auth test confirms 401 without valid token
- No test touches production code (pure read-only assertions)
- Existing test suites unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/06-apply-endpoint-core/06-03-SUMMARY.md`
</output>
