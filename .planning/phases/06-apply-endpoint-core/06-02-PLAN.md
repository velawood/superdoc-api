---
phase: 06-apply-endpoint-core
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/routes/apply.mjs
  - src/app.mjs
autonomous: true

must_haves:
  truths:
    - "POST /v1/apply with a DOCX file and JSON edits returns a DOCX binary with Content-Disposition header"
    - "Invalid edits are rejected with 400 status and full error list before any edits are applied"
    - "The response DOCX is recompressed (smaller than SuperDoc's uncompressed output)"
    - "Missing file returns 400 MISSING_FILE, missing edits returns 400 MISSING_EDITS"
    - "Invalid JSON in edits field returns 400 INVALID_EDITS_JSON"
    - "Document load failure returns 422 DOCUMENT_LOAD_FAILED"
    - "Edit application failure returns 422 APPLY_FAILED"
    - "Resource cleanup (editor + semaphore) runs on all code paths"
  artifacts:
    - path: "src/routes/apply.mjs"
      provides: "POST /apply route handler with multipart parsing, validation, edit application, recompression, and binary response"
      exports: ["default"]
    - path: "src/app.mjs"
      provides: "App factory registering apply routes under /v1 scope"
      contains: "applyRoutes"
  key_links:
    - from: "src/routes/apply.mjs"
      to: "src/utils/recompress.mjs"
      via: "import recompressDocxBuffer for DOCX compression"
      pattern: "recompressDocxBuffer"
    - from: "src/routes/apply.mjs"
      to: "src/utils/apply-buffer.mjs"
      via: "import applyEditsToBuffer for edit application"
      pattern: "applyEditsToBuffer"
    - from: "src/routes/apply.mjs"
      to: "src/editApplicator.mjs"
      via: "import validateEditsAgainstIR for edit validation"
      pattern: "validateEditsAgainstIR"
    - from: "src/routes/apply.mjs"
      to: "src/validation/file-upload.mjs"
      via: "import validateMagicBytes, checkZipBomb for file validation"
      pattern: "validateMagicBytes"
    - from: "src/app.mjs"
      to: "src/routes/apply.mjs"
      via: "scope.register(applyRoutes) inside /v1 protected scope"
      pattern: "applyRoutes"
---

<objective>
Create the POST /v1/apply route handler and register it in the app factory.

Purpose: This is the core apply endpoint that ties together all the pieces: multipart parsing (Phase 3), file validation (Phase 3), resource management (Phase 5), edit validation + application (domain modules via Phase 6 Plan 1 utilities), and DOCX recompression. This fulfills APPLY-01 (POST endpoint), APPLY-02 (reject invalid edits with full error list), APPLY-03 (recompressed DOCX), and APPLY-04 (JSON edit format support).

Output: New route handler at src/routes/apply.mjs and updated app.mjs to register it under /v1 scope.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-apply-endpoint-core/06-RESEARCH.md
@.planning/phases/06-apply-endpoint-core/06-01-SUMMARY.md

@src/app.mjs
@src/routes/read.mjs
@src/hooks/content-type-check.mjs
@src/validation/file-upload.mjs
@src/editorFactory.mjs
@src/irExtractor.mjs
@src/editApplicator.mjs
@src/utils/recompress.mjs
@src/utils/apply-buffer.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create apply route handler</name>
  <files>src/routes/apply.mjs</files>
  <action>
Create `src/routes/apply.mjs` following the pattern established by `src/routes/read.mjs`.

Imports:
```javascript
import { createHeadlessEditor } from "../editorFactory.mjs";
import { extractIRFromEditor } from "../irExtractor.mjs";
import { validateEditsAgainstIR } from "../editApplicator.mjs";
import { validateMagicBytes, checkZipBomb } from "../validation/file-upload.mjs";
import { recompressDocxBuffer } from "../utils/recompress.mjs";
import { applyEditsToBuffer } from "../utils/apply-buffer.mjs";
import { requireMultipart } from "../hooks/content-type-check.mjs";
```

Export default async function `applyRoutes(fastify, opts)` that registers:

`fastify.post("/apply", { preHandler: [requireMultipart] }, async (request, reply) => { ... })`

The handler must follow this exact flow:

**Step 1: Parse multipart fields using request.parts().**
Use `for await (const part of request.parts())` to handle mixed content (file + JSON field). This is different from the read route which uses `request.file()` for single-file upload.
- If `part.type === 'file'`: buffer the file with `await part.toBuffer()`, capture filename.
- If `part.fieldname === 'edits'`: parse JSON with `JSON.parse(part.value)`. On parse error, immediately return 400 `INVALID_EDITS_JSON` with `details: [{ field: "edits", reason: error.message }]`.
- Ignore other fields silently.

IMPORTANT: Collect ALL parts before processing. Do NOT assume field ordering (file might arrive after edits).

**Step 2: Validate required fields.**
- If `!fileBuffer`: return 400 `MISSING_FILE`, message "No file uploaded"
- If `!editsJson`: return 400 `MISSING_EDITS`, message "Edits field is required and must be a JSON array"
- If `!Array.isArray(editsJson)`: return 400 `MISSING_EDITS`, message "Edits field must be a JSON array"

**Step 3: Validate DOCX file (reuse Phase 3 validation pipeline).**
- `validateMagicBytes(fileBuffer)` -> if invalid, return 400 `INVALID_FILE_TYPE`
- `await checkZipBomb(fileBuffer)` -> if unsafe, return 400 `ZIP_BOMB_DETECTED`

**Step 4: Acquire semaphore and create editor.**
- Acquire: `await fastify.documentSemaphore.acquire()`
- Create editor: `const { editor, cleanup } = await createHeadlessEditor(fileBuffer, { documentMode: 'suggesting', user: { name: 'API User', email: 'api@superdoc.com' } })`
- Store cleanup on request: `request.editorCleanup = cleanup` (for Phase 5 onResponse hook)
- On editor creation failure: call `cleanup()` if exists, release semaphore `fastify.documentSemaphore.release()`, set `request.editorCleanup = null`, return 422 `DOCUMENT_LOAD_FAILED`

NOTE: Phase 5 modifies createHeadlessEditor to return `{ editor, cleanup }` instead of just editor. If Phase 5 is NOT yet executed when this plan runs, adapt: use the current return value (just editor) and create a manual cleanup function that calls `editor.destroy()`. The plan should handle both shapes gracefully. Check `if (typeof editorResult === 'object' && editorResult.cleanup)` to detect Phase 5 shape.

**Step 5: Extract IR and validate edits (inside try block).**
- `const ir = extractIRFromEditor(editor, filename)`
- `const validation = validateEditsAgainstIR(editsJson, ir)`
- If `!validation.valid`: return 400 `INVALID_EDITS` with details mapped from `validation.issues` (each issue: editIndex, blockId, type, message). This is APPLY-02: reject entire request with full error list. Do NOT apply any edits.

**Step 6: Apply edits.**
- `const modifiedBuffer = await applyEditsToBuffer(editor, editsJson, ir, { author: { name: 'API User', email: 'api@superdoc.com' } })`
- On failure: return 422 `APPLY_FAILED`, message "Unable to apply edits to document"

**Step 7: Recompress DOCX.**
- `const finalBuffer = await recompressDocxBuffer(modifiedBuffer)`
- On recompression failure: log warning, fall back to `modifiedBuffer` (availability > compression per research open question #1)

**Step 8: Return binary DOCX response.**
- Sanitize filename: strip characters that break Content-Disposition headers (quotes, backslashes, newlines, non-ASCII). Replace stripped chars with underscore. Append `-edited.docx` suffix.
- Set headers:
  - `Content-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document`
  - `Content-Disposition: attachment; filename="<sanitized-filename>"`
- Send buffer: `reply.send(finalBuffer)`

**Step 9: Resource cleanup in finally block.**
- Wrap steps 5-8 in try-finally
- In finally: the Phase 5 onResponse hook handles cleanup and semaphore release via `request.editorCleanup`
- On error paths BEFORE editor creation: no cleanup needed (semaphore not acquired)
- On error paths AFTER editor creation but BEFORE try block: manual cleanup + semaphore release

Error code summary:
- 400 INVALID_EDITS_JSON: Malformed JSON in edits field
- 400 MISSING_FILE: No file in multipart
- 400 MISSING_EDITS: No edits field or not an array
- 400 INVALID_FILE_TYPE: Bad magic bytes
- 400 ZIP_BOMB_DETECTED: Suspicious compression ratio
- 400 INVALID_EDITS: Edit validation failed (with full issue list in details)
- 422 DOCUMENT_LOAD_FAILED: SuperDoc can't load the document
- 422 APPLY_FAILED: Edits valid but application failed (SuperDoc error)

Add comprehensive JSDoc header documenting the endpoint, multipart fields, response format, and all error codes (follow the pattern in read.mjs).
  </action>
  <verify>
Run `node -e "import('./src/routes/apply.mjs').then(m => console.log(typeof m.default))"` to verify the module loads and exports a function.
  </verify>
  <done>
POST /apply route handler created at src/routes/apply.mjs. Handles multipart parsing with request.parts(), validates file and edits, creates editor with resource management integration, validates edits against IR (APPLY-02), applies edits, recompresses output (APPLY-03), and returns binary DOCX with proper headers. All error paths return structured JSON responses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register apply routes in app factory</name>
  <files>src/app.mjs</files>
  <action>
Update `src/app.mjs` to register the apply routes.

1. Add import at the top: `import applyRoutes from "./routes/apply.mjs";`

2. Inside the `protectedRoutes` scope (the async function registered with `{ prefix: "/v1" }`), add `scope.register(applyRoutes);` after the existing `scope.register(readRoutes);` line.

That's it. The apply routes will inherit:
- Bearer auth from the /v1 scope
- The /v1 prefix (so /apply becomes /v1/apply)
- The global multipart plugin
- The global concurrency limiter and resource cleanup (from Phase 5)

IMPORTANT: Do NOT modify any other registrations or imports. Only add the applyRoutes import and registration.
  </action>
  <verify>
Run `node -e "import('./src/app.mjs').then(m => { const app = m.default({ logger: false, apiKey: 'test' }); app.ready().then(() => { console.log('routes:', app.printRoutes()); app.close(); }); })"` to verify the app boots with the apply route registered.
Run `node --test tests_and_others/tests/server.test.mjs` to verify existing server tests still pass.
  </verify>
  <done>
Apply routes registered under /v1 scope in src/app.mjs. POST /v1/apply is available with auth, multipart, and resource management. Existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `node -e "import('./src/routes/apply.mjs').then(m => console.log(typeof m.default))"` - Apply route module loads
2. `node --test tests_and_others/tests/server.test.mjs` - Server bootstrap tests pass
3. `node --test tests_and_others/tests/auth.test.mjs` - Auth tests pass
4. `node --test tests_and_others/tests/read.test.mjs` - Read endpoint tests pass (unaffected)
5. App boots with apply route: `node -e "import('./src/app.mjs').then(m => { const app = m.default({ logger: false, apiKey: 'test' }); app.ready().then(() => { app.close(); console.log('OK'); }); })"`
</verification>

<success_criteria>
- POST /v1/apply route registered and accessible with Bearer auth
- Route parses mixed multipart (file + JSON edits field) using request.parts()
- File validation pipeline (magic bytes + zip bomb) reused from Phase 3
- Edit validation rejects entire request with full error list (APPLY-02)
- Successful requests return recompressed DOCX with Content-Disposition header (APPLY-03)
- Resource management integrated (semaphore + cleanup) per Phase 5 patterns
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-apply-endpoint-core/06-02-SUMMARY.md`
</output>
