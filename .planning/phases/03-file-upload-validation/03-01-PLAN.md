---
phase: 03-file-upload-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/plugins/multipart.mjs
  - src/validation/file-upload.mjs
  - src/app.mjs
autonomous: true

must_haves:
  truths:
    - "Files larger than 50MB are rejected with 413 before reaching any route handler"
    - "Non-ZIP files (wrong magic bytes) are rejected with 400 and INVALID_FILE_TYPE code"
    - "ZIP bombs (high compression ratio) are rejected with 400 and ZIP_BOMB_DETECTED code"
    - "The multipart plugin is registered globally so all future upload routes inherit size limits"
    - "Validation functions are reusable for any route that accepts file uploads"
  artifacts:
    - path: "src/plugins/multipart.mjs"
      provides: "@fastify/multipart registration with 50MB size limit"
      contains: "fastify.register(multipart"
    - path: "src/validation/file-upload.mjs"
      provides: "validateMagicBytes and checkZipBomb functions"
      exports: ["validateMagicBytes", "checkZipBomb"]
    - path: "package.json"
      provides: "@fastify/multipart dependency"
      contains: "@fastify/multipart"
  key_links:
    - from: "src/app.mjs"
      to: "src/plugins/multipart.mjs"
      via: "app.register(multipartPlugin)"
      pattern: "register.*multipart"
    - from: "src/validation/file-upload.mjs"
      to: "unzipper"
      via: "Open.buffer() for central directory reading"
      pattern: "Open\\.buffer"
---

<objective>
Install @fastify/multipart and implement the three-layer file upload validation pipeline: size limiting (via multipart plugin), magic byte validation, and zip bomb detection.

Purpose: Protect the server from malicious or oversized file uploads before any document processing begins. This is a prerequisite for the read and apply endpoints.
Output: Multipart plugin registered in app, reusable validation module with magic byte and zip bomb checks.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-file-upload-validation/03-RESEARCH.md
@.planning/phases/02-auth-and-error-handling/02-01-SUMMARY.md
@src/app.mjs
@src/plugins/error-handler.mjs
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @fastify/multipart and create multipart plugin</name>
  <files>package.json, src/plugins/multipart.mjs</files>
  <action>
1. Install the dependency:
   ```bash
   npm install @fastify/multipart
   ```

2. Create `src/plugins/multipart.mjs`:
   - Import `fp` from "fastify-plugin" and `multipart` from "@fastify/multipart"
   - Define `DEFAULT_FILE_SIZE_LIMIT = 50 * 1024 * 1024` (50MB)
   - Read file size limit from `process.env.MAX_FILE_SIZE`, falling back to DEFAULT_FILE_SIZE_LIMIT
   - Parse the env var with `parseInt(..., 10)`
   - Register @fastify/multipart with these limits:
     - `fileSize`: the computed limit
     - `files: 1` (one file per request)
     - `fields: 10` (reasonable field limit)
     - `headerPairs: 100`
   - Leave `throwFileSizeLimit` at default `true` (auto-throws RequestFileTooLargeError with 413)
   - Wrap with `fp(multipartPlugin, { name: "multipart" })` to make it non-encapsulated (global)
   - Export as default

IMPORTANT: The plugin must be wrapped with fastify-plugin (like request-id and error-handler) so it's available globally. Unlike the auth plugin which is route-scoped.

PITFALL: Fastify's default `bodyLimit` (1MB) may conflict with the 50MB multipart fileSize. When registering the multipart plugin, the plugin registers its own content type parser for multipart/form-data, which should bypass the global body limit. However, test with files near the limit to verify. If Fastify rejects before multipart can parse, you may need to increase the Fastify bodyLimit in buildApp().
  </action>
  <verify>
    Run `node -e "import m from '@fastify/multipart'; console.log('ok')"` to confirm the package installed correctly.
    Verify `src/plugins/multipart.mjs` exists and exports a fastify-plugin wrapped function.
  </verify>
  <done>
    @fastify/multipart is in package.json dependencies. src/plugins/multipart.mjs exports a Fastify plugin that registers multipart with a 50MB file size limit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create file upload validation module and wire into app</name>
  <files>src/validation/file-upload.mjs, src/app.mjs</files>
  <action>
1. Create `src/validation/file-upload.mjs` with two exported functions:

   **validateMagicBytes(buffer):**
   - Define `ZIP_MAGIC = Buffer.from([0x50, 0x4B, 0x03, 0x04])` (PK\x03\x04)
   - If buffer.length < 4, return `{ valid: false, error: "File too small to be a valid DOCX" }`
   - If first 4 bytes don't match ZIP_MAGIC (use `buffer.subarray(0, 4).equals(ZIP_MAGIC)`), return `{ valid: false, error: "Invalid file format: not a ZIP/DOCX file (bad magic bytes)" }`
   - Otherwise return `{ valid: true }`

   **checkZipBomb(buffer, opts = {}):**
   - Import unzipper: try `import { Open } from "unzipper"` first. If named import fails at runtime, use `import unzipper from "unzipper"` and destructure `const { Open } = unzipper`. Test which pattern works during implementation since unzipper is CJS.
   - Define defaults: `DEFAULT_MAX_RATIO = 100`, `DEFAULT_MAX_DECOMPRESSED = 500 * 1024 * 1024` (500MB)
   - Extract `maxRatio` and `maxDecompressedSize` from opts with defaults
   - Wrap `Open.buffer(buffer)` in try/catch -- if it throws, return `{ safe: false, error: "Corrupted or invalid ZIP/DOCX file" }`
   - Sum `file.uncompressedSize || 0` for all files in `directory.files`
   - Calculate ratio: `totalUncompressed / buffer.length` (guard against 0)
   - If `totalUncompressed > maxDecompressed`, return `{ safe: false, error: "Decompressed size exceeds maximum allowed", ratio, totalUncompressed }`
   - If `ratio > maxRatio`, return `{ safe: false, error: "Suspicious compression ratio detected", ratio, totalUncompressed }`
   - Otherwise return `{ safe: true, ratio, totalUncompressed }`

2. Wire multipart plugin into `src/app.mjs`:
   - Import multipartPlugin from "./plugins/multipart.mjs"
   - Register it AFTER error-handler but BEFORE route registration: `app.register(multipartPlugin)`
   - This goes between the existing `app.register(errorHandlerPlugin)` and the health route registration

Do NOT create any upload routes yet -- those come in Phase 4. The validation module is a library that future route handlers will import and call.
  </action>
  <verify>
    Run `node -e "import { validateMagicBytes, checkZipBomb } from './src/validation/file-upload.mjs'; console.log('imports ok')"` from the project root to confirm the module loads.
    Run `npm test` to verify existing tests still pass (no regressions from app.mjs changes).
  </verify>
  <done>
    src/validation/file-upload.mjs exports validateMagicBytes and checkZipBomb. src/app.mjs registers the multipart plugin globally. All existing tests pass without regression.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes -- no regressions from new plugin registration or app.mjs changes
2. `node -e "import { validateMagicBytes, checkZipBomb } from './src/validation/file-upload.mjs'; const r = validateMagicBytes(Buffer.from([0x50,0x4B,0x03,0x04,0,0,0,0])); console.log(r.valid)"` prints `true`
3. `node -e "import { validateMagicBytes } from './src/validation/file-upload.mjs'; const r = validateMagicBytes(Buffer.from([0x89,0x50,0x4e,0x47])); console.log(r.valid)"` prints `false`
4. `grep -q '@fastify/multipart' package.json` succeeds
5. `grep -q 'multipartPlugin' src/app.mjs` succeeds
</verification>

<success_criteria>
- @fastify/multipart installed and registered as global plugin with 50MB file size limit
- validateMagicBytes correctly identifies ZIP headers and rejects non-ZIP files
- checkZipBomb reads ZIP central directory without decompressing and rejects high-ratio archives
- Existing tests pass without regression
- No upload routes created yet (those are Phase 4)
</success_criteria>

<output>
After completion, create `.planning/phases/03-file-upload-validation/03-01-SUMMARY.md`
</output>
