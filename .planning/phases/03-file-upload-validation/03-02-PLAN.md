---
phase: 03-file-upload-validation
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - tests_and_others/tests/file-upload-validation.test.mjs
autonomous: true

must_haves:
  truths:
    - "Uploading a file larger than the configured size limit returns 413 with structured error body"
    - "Uploading a non-DOCX file (PNG renamed to .docx) is rejected based on magic byte validation"
    - "Uploading a zip bomb is detected and rejected before full decompression"
    - "Valid DOCX files pass all three validation checks"
    - "Corrupted ZIP files (valid magic bytes but bad structure) are handled gracefully"
  artifacts:
    - path: "tests_and_others/tests/file-upload-validation.test.mjs"
      provides: "Complete test coverage for Phase 3 file upload validation"
      min_lines: 100
  key_links:
    - from: "tests_and_others/tests/file-upload-validation.test.mjs"
      to: "src/validation/file-upload.mjs"
      via: "import { validateMagicBytes, checkZipBomb }"
      pattern: "validateMagicBytes|checkZipBomb"
    - from: "tests_and_others/tests/file-upload-validation.test.mjs"
      to: "src/app.mjs"
      via: "buildApp() + app.inject() for integration tests"
      pattern: "app\\.inject"
---

<objective>
Write comprehensive tests for the three-layer file upload validation: size limits (413), magic byte validation (400), and zip bomb detection (400). Uses TDD red-green cycle where tests define the expected behavior.

Purpose: Verify all Phase 3 success criteria are met with automated tests that prove malicious/oversized uploads are rejected.
Output: Test file covering unit tests for validation functions and integration tests for the multipart pipeline.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-file-upload-validation/03-RESEARCH.md
@.planning/phases/03-file-upload-validation/03-01-SUMMARY.md
@src/validation/file-upload.mjs
@src/plugins/multipart.mjs
@src/app.mjs
@src/hooks/content-type-check.mjs
@tests_and_others/tests/server.test.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write unit tests for validateMagicBytes and checkZipBomb</name>
  <files>tests_and_others/tests/file-upload-validation.test.mjs</files>
  <action>
Create `tests_and_others/tests/file-upload-validation.test.mjs` with these test suites:

**Suite 1: validateMagicBytes (unit tests)**

Test cases:
- Valid ZIP header (PK\x03\x04) returns `{ valid: true }`
- Valid ZIP header with trailing data returns `{ valid: true }` (real DOCX files have data after header)
- PNG header (0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A) returns `{ valid: false }` with error mentioning "magic bytes"
- PDF header (%PDF = 0x25, 0x50, 0x44, 0x46) returns `{ valid: false }`
- Empty buffer (0 bytes) returns `{ valid: false }` with error mentioning "too small"
- 2-byte buffer (only PK, no \x03\x04) returns `{ valid: false }` with error mentioning "too small"
- 3-byte buffer returns `{ valid: false }` with error mentioning "too small"
- Exactly 4 bytes matching ZIP magic returns `{ valid: true }`

Create test buffers inline:
```javascript
const VALID_ZIP = Buffer.from([0x50, 0x4B, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00]);
const PNG_HEADER = Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);
const PDF_HEADER = Buffer.from([0x25, 0x50, 0x44, 0x46]);
const TINY_BUFFER = Buffer.from([0x50, 0x4B]);
```

**Suite 2: checkZipBomb (unit tests)**

For these tests, you need a real minimal ZIP file. Create one using Node.js `archiver` (already in dependencies) or use a pre-built buffer.

Easiest approach: Create a helper function that builds a minimal valid ZIP buffer using the archiver library:

```javascript
import archiver from "archiver";
import { Writable } from "node:stream";

async function createZipBuffer(entries) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    const writable = new Writable({
      write(chunk, encoding, callback) {
        chunks.push(chunk);
        callback();
      }
    });
    writable.on("finish", () => resolve(Buffer.concat(chunks)));

    const archive = archiver("zip", { zlib: { level: 9 } });
    archive.on("error", reject);
    archive.pipe(writable);

    for (const { name, content } of entries) {
      archive.append(content, { name });
    }
    archive.finalize();
  });
}
```

Test cases:
- Normal ZIP (small text file, ratio ~2:1) returns `{ safe: true }` with ratio and totalUncompressed
- ZIP with reasonable content (1MB text in ZIP) returns `{ safe: true }` with ratio well under 100
- ZIP with high ratio (construct by setting maxRatio very low, e.g., opts.maxRatio = 1) returns `{ safe: false }` with error mentioning "compression ratio"
- ZIP with large decompressed size (set maxDecompressedSize very low, e.g., 100 bytes) returns `{ safe: false }` with error mentioning "Decompressed size"
- Invalid ZIP (valid magic bytes but corrupted body) returns `{ safe: false }` with error mentioning "Corrupted"
- checkZipBomb returns ratio and totalUncompressed in result for safe files

For the "corrupted ZIP" test, create a buffer with PK\x03\x04 header followed by random/zeroed bytes that don't form a valid ZIP structure.

**Important:** Import from the validation module:
```javascript
import { validateMagicBytes, checkZipBomb } from "../../src/validation/file-upload.mjs";
```

Run tests after writing: `node --test tests_and_others/tests/file-upload-validation.test.mjs`

If any test fails, fix the issue in the test or flag the validation module issue. For TDD: tests define the contract, implementation must match.
  </action>
  <verify>
    Run `node --test tests_and_others/tests/file-upload-validation.test.mjs` -- all unit tests pass.
  </verify>
  <done>
    Unit tests for validateMagicBytes cover valid ZIP, invalid formats (PNG, PDF), and edge cases (empty, tiny buffers). Unit tests for checkZipBomb cover normal ZIP, ratio threshold, decompressed size threshold, and corrupted ZIP handling. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for multipart upload pipeline</name>
  <files>tests_and_others/tests/file-upload-validation.test.mjs</files>
  <action>
Add integration test suites to the same test file. These use `buildApp()` + `app.inject()` with multipart payloads.

**Helper function for building multipart payloads:**

```javascript
function buildMultipartPayload(filename, content, fieldName = "file") {
  const boundary = "----FormBoundary" + Date.now();
  const header = Buffer.from(
    `--${boundary}\r\n` +
    `Content-Disposition: form-data; name="${fieldName}"; filename="${filename}"\r\n` +
    `Content-Type: application/octet-stream\r\n\r\n`
  );
  const footer = Buffer.from(`\r\n--${boundary}--\r\n`);
  const payload = Buffer.concat([header, content, footer]);
  return {
    payload,
    contentType: `multipart/form-data; boundary=${boundary}`,
  };
}
```

**Suite 3: File size limit (integration, AUTH-03)**

Register a test upload route in `before()` hook that calls `request.file()` + `data.toBuffer()` and returns the buffer size. This route needs:
- The `requireMultipart` preHandler from `src/hooks/content-type-check.mjs`
- To be inside the /v1 scope (needs auth) OR at root level (simpler for testing)

For simplicity, register the test route at root level (like the existing test-error route pattern in server.test.mjs). The multipart plugin is global so it applies everywhere.

Test cases:
- File under 50MB limit returns 200 (use a small buffer, e.g., 1KB with valid ZIP header)
- File exceeding limit returns 413 with structured error body (create a buffer > 50MB -- BUT this will be slow. Instead, create the app with a very small MAX_FILE_SIZE env var or override)

**IMPORTANT for size limit test:** Don't allocate a 60MB buffer. Instead:
- Set `process.env.MAX_FILE_SIZE = "1024"` (1KB) before building the app for that test suite
- Send a 2KB file, expect 413
- Clean up env var in `after()`

Test the 413 response has structured error JSON: `{ error: { code, message, details } }`

**Suite 4: Full validation pipeline (integration)**

Register a test upload route that:
1. Calls `request.file()` to get the multipart file
2. Calls `data.toBuffer()` to buffer it
3. Calls `validateMagicBytes(buffer)` -- if invalid, returns 400 with INVALID_FILE_TYPE
4. Calls `checkZipBomb(buffer)` -- if unsafe, returns 400 with ZIP_BOMB_DETECTED
5. Returns 200 with `{ valid: true }` if all checks pass

Test cases:
- Valid ZIP file passes all checks, returns 200
- PNG file renamed to .docx returns 400 with INVALID_FILE_TYPE code
- Missing file field in multipart returns 400 with MISSING_FILE code (handle null from request.file())

**Suite 5: Error handler integration**

Verify that multipart errors produce structured JSON responses (not raw Fastify errors):
- 413 response has `error.code`, `error.message`, `error.details` structure
- Response Content-Type is application/json

Run ALL tests after writing: `npm test` to verify no regressions.
  </action>
  <verify>
    Run `npm test` -- all tests pass including new file-upload-validation tests and all existing server tests.
  </verify>
  <done>
    Integration tests verify: file size limit returns 413 with structured error, magic byte rejection returns 400 with INVALID_FILE_TYPE, full validation pipeline works end-to-end via app.inject(). All existing tests continue to pass.
  </done>
</task>

</tasks>

<verification>
1. `node --test tests_and_others/tests/file-upload-validation.test.mjs` -- all tests pass
2. `npm test` -- all test files pass with zero failures
3. Tests cover all three Phase 3 success criteria:
   - AUTH-03: File size > limit returns 413 (integration test with low limit)
   - AUTH-05: Non-ZIP file returns 400 with INVALID_FILE_TYPE (unit + integration)
   - AUTH-07: Zip bomb detected and rejected (unit test with low ratio threshold)
4. Edge cases covered: empty buffer, tiny buffer, corrupted ZIP, missing file field
</verification>

<success_criteria>
- All validateMagicBytes unit tests pass (valid ZIP, PNG, PDF, empty, tiny)
- All checkZipBomb unit tests pass (normal ZIP, ratio threshold, size threshold, corrupted)
- Integration tests prove 413 for oversized files with structured error
- Integration tests prove 400 for non-ZIP files with INVALID_FILE_TYPE
- Full test suite (npm test) passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-file-upload-validation/03-02-SUMMARY.md`
</output>
