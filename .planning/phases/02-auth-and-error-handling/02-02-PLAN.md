---
phase: 02-auth-and-error-handling
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - tests_and_others/tests/auth.test.mjs
autonomous: true

must_haves:
  truths:
    - "Valid Bearer token passes through to /v1 endpoints"
    - "Missing Authorization header returns 401 with structured error"
    - "Invalid API key returns 401 with same generic message (no info leak)"
    - "Root /health works without auth"
    - "/v1/health requires auth"
    - "POST to upload route without multipart/form-data returns 400"
    - "500 errors never expose file paths or stack traces"
    - "4xx errors with unsafe messages are scrubbed"
  artifacts:
    - path: "tests_and_others/tests/auth.test.mjs"
      provides: "Comprehensive auth, content-type, and error sanitization tests"
      min_lines: 80
  key_links:
    - from: "tests_and_others/tests/auth.test.mjs"
      to: "src/app.mjs"
      via: "buildApp() + inject()"
      pattern: "buildApp.*inject"
    - from: "tests_and_others/tests/auth.test.mjs"
      to: "src/hooks/content-type-check.mjs"
      via: "test route with preHandler: requireMultipart"
      pattern: "requireMultipart"
---

<objective>
TDD test suite proving all Phase 2 auth, Content-Type validation, and error sanitization behaviors.

Purpose: Lock down the security contract with automated tests. Every auth bypass, info leak, or missing validation becomes a regression test.
Output: Comprehensive test file covering AUTH-01, AUTH-02, AUTH-04, and AUTH-06 requirements.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-auth-and-error-handling/02-RESEARCH.md
@.planning/phases/02-auth-and-error-handling/02-01-SUMMARY.md
@src/app.mjs
@src/plugins/auth.mjs
@src/plugins/error-handler.mjs
@src/hooks/content-type-check.mjs
@tests_and_others/tests/server.test.mjs
</context>

<feature>
  <name>Auth, Content-Type Validation, and Error Sanitization Tests</name>
  <files>tests_and_others/tests/auth.test.mjs</files>
  <behavior>
    Test suites covering all Phase 2 success criteria:

    **Suite 1: Authentication (AUTH-01, AUTH-02)**
    - GET /v1/health with valid Bearer token -> 200 {status: "ok"}
    - GET /v1/health without Authorization header -> 401 {error: {code: "UNAUTHORIZED"}}
    - GET /v1/health with wrong API key -> 401 {error: {code: "UNAUTHORIZED"}}
    - GET /v1/health with malformed auth header (no "Bearer " prefix) -> 401
    - 401 response message is always "Invalid or missing API key" (no info about WHY it failed)
    - GET /health (root) without auth -> 200 (infrastructure probe stays open)

    **Suite 2: Content-Type Validation (AUTH-04)**
    Register a test POST route inside the protected /v1 scope with `preHandler: requireMultipart` in the before() hook.
    - POST /v1/test-upload with application/json -> 400 {error: {code: "INVALID_CONTENT_TYPE"}}
    - POST /v1/test-upload with no Content-Type -> 400
    - POST /v1/test-upload with multipart/form-data -> passes preHandler (route executes)
    Note: The test route is registered at test time using `app.register()` inside the protectedRoutes scope. Alternatively, register a fresh app with an additional test route inside the protected scope. Follow the pattern from Phase 1 tests (01-02) where test routes are registered in before() hooks.

    **Suite 3: Error Sanitization (AUTH-06)**
    Register test routes that throw errors containing internal details (file paths, stack traces, module names). Use the protected /v1 scope so auth is also tested.
    - Route throwing Error("ENOENT /src/app.mjs") -> 500 response body does NOT contain "/src/" or ".mjs"
    - Route throwing Error with stack trace -> response body does NOT contain "at " or "node_modules"
    - 500 error message is always "An internal server error occurred"
    - Route throwing 4xx error with unsafe message (contains file path) -> message is scrubbed to "Bad request"
    - Route throwing 4xx error with safe message ("Invalid input") -> message passes through as-is

    **Testing patterns:**
    - Use node:test (describe, it, before, after)
    - Use node:assert/strict
    - Separate app instance per describe suite (Phase 1 pattern)
    - Set process.env.API_KEY in before(), delete in after()
    - All requests to /v1/* include `headers: { authorization: "Bearer ${TEST_API_KEY}" }` except auth-negative tests
    - Import requireMultipart from src/hooks/content-type-check.mjs for the content-type test suite
  </behavior>
  <implementation>
    Create tests_and_others/tests/auth.test.mjs following existing server.test.mjs conventions:

    RED phase:
    1. Write all test cases described above
    2. Run tests: `node --test tests_and_others/tests/auth.test.mjs`
    3. Tests should PASS (implementation from 02-01 already exists)
    4. If any test fails, that reveals a gap in the 02-01 implementation -- fix the implementation to pass

    GREEN phase:
    Since this is TDD after implementation (02-01 ships first), expect tests to pass immediately. If any fail, make minimal fixes to implementation files.

    REFACTOR phase:
    Review test structure. Ensure:
    - No duplicate setup code across suites
    - Clear test names that describe the behavior being verified
    - Assertions check both status code AND response body structure

    For the Content-Type test suite, the test route registration requires care:
    - Build the app with buildApp()
    - Before app.ready(), register a test route inside the /v1 scope that uses requireMultipart as preHandler
    - One approach: Create a fresh buildApp() and add `app.register(async function(scope) { scope.post("/test-upload", { preHandler: requireMultipart }, async () => ({ ok: true })); }, { prefix: "/v1" })` in the before() hook
    - BUT: the protectedRoutes scope in app.mjs already has auth. So you need to register the test route INSIDE that scope, or register a parallel /v1 scope. The simplest approach: register the test route directly on the app instance at a non-/v1 path first to test the hook in isolation, then test it with auth by hitting /v1. Actually, the cleanest approach is to modify the buildApp() to accept an optional callback for registering additional routes inside the protected scope. BUT that changes production code for tests.
    - BEST approach: Build the app normally, then register a test POST route on the app before ready(). Since @fastify/bearer-auth is scoped inside protectedRoutes, a route registered at the top level won't have auth. To test content-type WITH auth, register inside a new /v1 sub-scope. The auth from protectedRoutes won't leak to a separately-registered /v1 scope because they're different plugin contexts.
    - SIMPLEST approach: Test requireMultipart in isolation (separate suite without auth) by building a minimal Fastify instance with just the hook. Then separately verify that /v1 routes have auth. This keeps the content-type tests focused.
  </implementation>
</feature>

<verification>
1. `node --test tests_and_others/tests/auth.test.mjs` -- all tests pass
2. `npm test` -- all tests pass (existing + new, zero regressions)
3. Test count: at least 12 new test cases covering auth, content-type, and error sanitization
</verification>

<success_criteria>
- tests_and_others/tests/auth.test.mjs exists with 12+ test cases
- All Phase 2 success criteria have corresponding test assertions:
  1. Valid Bearer token passes -> tested
  2. Missing/invalid key returns 401 with structured body -> tested
  3. POST without multipart/form-data returns 400 -> tested
  4. Internal errors have safe messages (no file paths, stack traces) -> tested
- All tests pass
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/02-auth-and-error-handling/02-02-SUMMARY.md`
</output>
