---
phase: 02-auth-and-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/plugins/auth.mjs
  - src/app.mjs
  - src/plugins/error-handler.mjs
  - src/hooks/content-type-check.mjs
autonomous: true

must_haves:
  truths:
    - "Requests with valid Bearer token to /v1/* pass through to the endpoint"
    - "Requests without valid Bearer token to /v1/* receive 401"
    - "Root /health remains accessible without any authentication"
    - "/v1/health requires authentication like all /v1 routes"
    - "Server refuses to start when API_KEY env var is missing"
    - "Error responses never contain file paths, stack traces, or library details"
    - "The requireMultipart hook rejects non-multipart requests with 400"
  artifacts:
    - path: "src/plugins/auth.mjs"
      provides: "Bearer token auth plugin scoped to protected routes"
      contains: "@fastify/bearer-auth"
    - path: "src/hooks/content-type-check.mjs"
      provides: "Reusable preHandler for multipart/form-data validation"
      exports: ["requireMultipart"]
    - path: "src/app.mjs"
      provides: "App factory with protected /v1 scope"
      contains: "protectedRoutes"
    - path: "src/plugins/error-handler.mjs"
      provides: "Sanitized error responses"
      contains: "isSafeMessage"
  key_links:
    - from: "src/app.mjs"
      to: "src/plugins/auth.mjs"
      via: "scope.register(authPlugin) inside protectedRoutes"
      pattern: "register.*authPlugin"
    - from: "src/plugins/auth.mjs"
      to: "@fastify/bearer-auth"
      via: "fastify.register(bearerAuth)"
      pattern: "register.*bearerAuth"
    - from: "src/plugins/error-handler.mjs"
      to: "isSafeMessage"
      via: "message sanitization before sending 4xx errors"
      pattern: "isSafeMessage"
---

<objective>
Implement API key authentication, Content-Type validation hook, and error sanitization for the Fastify server.

Purpose: Unauthorized requests must be rejected before reaching any endpoint, and error responses must never leak internal details. This is the security foundation for all future API endpoints.
Output: Auth plugin (scoped to /v1), Content-Type validation hook (for future upload routes), and hardened error handler.
</objective>

<execution_context>
@/Users/alin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-auth-and-error-handling/02-RESEARCH.md
@src/app.mjs
@src/plugins/error-handler.mjs
@src/plugins/request-id.mjs
@src/routes/health.mjs
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @fastify/bearer-auth and create auth plugin with app.mjs rewiring</name>
  <files>package.json, src/plugins/auth.mjs, src/app.mjs</files>
  <action>
    1. Install @fastify/bearer-auth:
       `npm install @fastify/bearer-auth`

    2. Create `src/plugins/auth.mjs`:
       - Import `bearerAuth` from `@fastify/bearer-auth`
       - Accept `opts.apiKey` (for testing) or fall back to `process.env.API_KEY`
       - Fail-fast: throw `new Error("API_KEY environment variable is required")` if no API key found
       - Register `bearerAuth` with:
         - `keys: new Set([apiKey])`
         - `errorResponse` returning structured format: `{ error: { code: "UNAUTHORIZED", message: "Invalid or missing API key", details: [] } }`
       - Do NOT wrap with fastify-plugin (intentionally scoped -- auth must only apply inside the registration scope, not globally)
       - Add JSDoc export comment

    3. Modify `src/app.mjs`:
       - Import `authPlugin` from `./plugins/auth.mjs`
       - Keep root-level registrations unchanged: requestIdPlugin, errorHandlerPlugin, healthRoutes (root /health stays unprotected)
       - Remove the existing `app.register(healthRoutes, { prefix: "/v1" })` line
       - Add a scoped `protectedRoutes` async function registered with `{ prefix: "/v1" }`:
         ```
         app.register(async function protectedRoutes(scope) {
           scope.register(authPlugin);
           scope.register(healthRoutes);
           // Future: upload routes, read routes, etc.
         }, { prefix: "/v1" });
         ```
       - This ensures all /v1/* routes require Bearer auth while root /health remains open

    IMPORTANT: The auth plugin must NOT be wrapped with fastify-plugin. Phase 1 used fastify-plugin for request-id and error-handler because those need to be global. Auth is intentionally scoped. Do not follow the Phase 1 pattern here.
  </action>
  <verify>
    Run: `node -e "import('./src/app.mjs').then(m => { process.env.API_KEY='test'; const app = m.default(); app.ready().then(() => { console.log('OK'); app.close(); }) })"`
    Expected: "OK" printed (app starts without errors when API_KEY is set).

    Run: `node -e "import('./src/app.mjs').then(m => { const app = m.default(); app.ready().then(() => app.close()).catch(e => console.log('EXPECTED:', e.message)) })"`
    Expected: "EXPECTED: API_KEY environment variable is required" (fails fast without API_KEY).
  </verify>
  <done>
    - @fastify/bearer-auth installed in package.json dependencies
    - src/plugins/auth.mjs exists, exports async function (not wrapped with fastify-plugin)
    - src/app.mjs has protectedRoutes scope at /v1 with auth plugin registered inside it
    - Root /health registration is outside the protected scope
    - App starts when API_KEY is set, refuses to start when API_KEY is missing
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Content-Type validation hook and strengthen error sanitization</name>
  <files>src/hooks/content-type-check.mjs, src/plugins/error-handler.mjs</files>
  <action>
    1. Create `src/hooks/content-type-check.mjs`:
       - Export an async function `requireMultipart(request, reply)`
       - Check `request.headers["content-type"]` starts with `"multipart/form-data"`
       - If not, send 400 with structured error: `{ error: { code: "INVALID_CONTENT_TYPE", message: "Content-Type must be multipart/form-data", details: [] } }`
       - CRITICAL: `return reply` after `reply.send()` to stop Fastify from continuing to the route handler (see Pitfall 6 in research)
       - Add JSDoc comment explaining this is a route-level preHandler for upload endpoints
       - This hook is created now but will be attached to upload routes in Phase 3+

    2. Strengthen `src/plugins/error-handler.mjs`:
       - Add an `isSafeMessage(msg)` function above the plugin:
         - Returns false if msg is falsy or not a string
         - Returns false if msg matches file path patterns: `/\/(src|node_modules|dist|home|Users)\//i`
         - Returns false if msg matches stack trace patterns: `/at\s+\w+\s+\(/i`
         - Returns false if msg matches file extension patterns: `/\.(mjs|js|ts|cjs):/i`
         - Returns true otherwise
       - Modify the error handler's 4xx branch:
         - Current: `error.message` is passed through directly for non-500 errors
         - New: For non-500, non-validation errors, check `isSafeMessage(error.message)`. If safe, use it. If not safe, use `"Bad request"` as fallback.
       - Keep the existing 5xx behavior unchanged ("An internal server error occurred")
       - Keep the existing validation error behavior unchanged (field-level details)
       - Update the error code fallback: use `error.code || (statusCode >= 500 ? "INTERNAL_ERROR" : "BAD_REQUEST")`
       - Keep the setNotFoundHandler unchanged
       - Keep the fastify-plugin wrapping unchanged (error handler must remain global)
  </action>
  <verify>
    Run: `node -e "import { requireMultipart } from './src/hooks/content-type-check.mjs'; console.log(typeof requireMultipart)"`
    Expected: "function"

    Run: `node -e "
      import('./src/plugins/error-handler.mjs').then(m => console.log('Module loaded OK'));
    "`
    Expected: "Module loaded OK"
  </verify>
  <done>
    - src/hooks/content-type-check.mjs exists and exports requireMultipart function
    - requireMultipart sends 400 with INVALID_CONTENT_TYPE code and returns reply
    - src/plugins/error-handler.mjs contains isSafeMessage function
    - 4xx error messages are sanitized: file paths, stack traces, and module references are scrubbed
    - 5xx error messages still return generic "An internal server error occurred"
    - Validation errors still pass through field-level details
    - Existing server.test.mjs tests still pass (no regression)
  </done>
</task>

</tasks>

<verification>
1. `npm test` -- all existing 441 tests pass (zero regressions from Phase 1)
2. App starts with API_KEY set: `API_KEY=test node -e "import('./src/app.mjs').then(m => { const app = m.default(); app.ready().then(() => { console.log('started'); app.close(); }) })"`
3. App fails fast without API_KEY: start without env var, verify error thrown
4. Manual inject test (optional): Start app, confirm `/health` returns 200 without auth, `/v1/health` returns 401 without auth
</verification>

<success_criteria>
- @fastify/bearer-auth installed and configured
- Auth scoped to /v1 via Fastify encapsulation (not global hook with URL allowlist)
- Root /health unprotected, /v1/* protected
- Error handler sanitizes all messages (isSafeMessage check)
- Content-Type validation hook ready for Phase 3 upload routes
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-auth-and-error-handling/02-01-SUMMARY.md`
</output>
